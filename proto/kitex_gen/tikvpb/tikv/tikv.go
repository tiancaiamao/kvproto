// Code generated by Kitex v0.1.2. DO NOT EDIT.

package tikv

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/pingcap/kvproto/proto/kitex_gen/coprocessor"
	"github.com/pingcap/kvproto/proto/kitex_gen/kvrpcpb"
	"github.com/pingcap/kvproto/proto/kitex_gen/mpp"
	"github.com/pingcap/kvproto/proto/kitex_gen/raft_serverpb"
	"github.com/pingcap/kvproto/proto/kitex_gen/tikvpb"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return tikvServiceInfo
}

var tikvServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "Tikv"
	handlerType := (*tikvpb.Tikv)(nil)
	methods := map[string]kitex.MethodInfo{
		"KvGet":                  kitex.NewMethodInfo(kvGetHandler, newKvGetArgs, newKvGetResult, false),
		"KvScan":                 kitex.NewMethodInfo(kvScanHandler, newKvScanArgs, newKvScanResult, false),
		"KvPrewrite":             kitex.NewMethodInfo(kvPrewriteHandler, newKvPrewriteArgs, newKvPrewriteResult, false),
		"KvPessimisticLock":      kitex.NewMethodInfo(kvPessimisticLockHandler, newKvPessimisticLockArgs, newKvPessimisticLockResult, false),
		"KVPessimisticRollback":  kitex.NewMethodInfo(kVPessimisticRollbackHandler, newKVPessimisticRollbackArgs, newKVPessimisticRollbackResult, false),
		"KvTxnHeartBeat":         kitex.NewMethodInfo(kvTxnHeartBeatHandler, newKvTxnHeartBeatArgs, newKvTxnHeartBeatResult, false),
		"KvCheckTxnStatus":       kitex.NewMethodInfo(kvCheckTxnStatusHandler, newKvCheckTxnStatusArgs, newKvCheckTxnStatusResult, false),
		"KvCheckSecondaryLocks":  kitex.NewMethodInfo(kvCheckSecondaryLocksHandler, newKvCheckSecondaryLocksArgs, newKvCheckSecondaryLocksResult, false),
		"KvCommit":               kitex.NewMethodInfo(kvCommitHandler, newKvCommitArgs, newKvCommitResult, false),
		"KvImport":               kitex.NewMethodInfo(kvImportHandler, newKvImportArgs, newKvImportResult, false),
		"KvCleanup":              kitex.NewMethodInfo(kvCleanupHandler, newKvCleanupArgs, newKvCleanupResult, false),
		"KvBatchGet":             kitex.NewMethodInfo(kvBatchGetHandler, newKvBatchGetArgs, newKvBatchGetResult, false),
		"KvBatchRollback":        kitex.NewMethodInfo(kvBatchRollbackHandler, newKvBatchRollbackArgs, newKvBatchRollbackResult, false),
		"KvScanLock":             kitex.NewMethodInfo(kvScanLockHandler, newKvScanLockArgs, newKvScanLockResult, false),
		"KvResolveLock":          kitex.NewMethodInfo(kvResolveLockHandler, newKvResolveLockArgs, newKvResolveLockResult, false),
		"KvGC":                   kitex.NewMethodInfo(kvGCHandler, newKvGCArgs, newKvGCResult, false),
		"KvDeleteRange":          kitex.NewMethodInfo(kvDeleteRangeHandler, newKvDeleteRangeArgs, newKvDeleteRangeResult, false),
		"RawGet":                 kitex.NewMethodInfo(rawGetHandler, newRawGetArgs, newRawGetResult, false),
		"RawBatchGet":            kitex.NewMethodInfo(rawBatchGetHandler, newRawBatchGetArgs, newRawBatchGetResult, false),
		"RawPut":                 kitex.NewMethodInfo(rawPutHandler, newRawPutArgs, newRawPutResult, false),
		"RawBatchPut":            kitex.NewMethodInfo(rawBatchPutHandler, newRawBatchPutArgs, newRawBatchPutResult, false),
		"RawDelete":              kitex.NewMethodInfo(rawDeleteHandler, newRawDeleteArgs, newRawDeleteResult, false),
		"RawBatchDelete":         kitex.NewMethodInfo(rawBatchDeleteHandler, newRawBatchDeleteArgs, newRawBatchDeleteResult, false),
		"RawScan":                kitex.NewMethodInfo(rawScanHandler, newRawScanArgs, newRawScanResult, false),
		"RawDeleteRange":         kitex.NewMethodInfo(rawDeleteRangeHandler, newRawDeleteRangeArgs, newRawDeleteRangeResult, false),
		"RawBatchScan":           kitex.NewMethodInfo(rawBatchScanHandler, newRawBatchScanArgs, newRawBatchScanResult, false),
		"RawGetKeyTTL":           kitex.NewMethodInfo(rawGetKeyTTLHandler, newRawGetKeyTTLArgs, newRawGetKeyTTLResult, false),
		"RawCompareAndSwap":      kitex.NewMethodInfo(rawCompareAndSwapHandler, newRawCompareAndSwapArgs, newRawCompareAndSwapResult, false),
		"RawChecksum":            kitex.NewMethodInfo(rawChecksumHandler, newRawChecksumArgs, newRawChecksumResult, false),
		"UnsafeDestroyRange":     kitex.NewMethodInfo(unsafeDestroyRangeHandler, newUnsafeDestroyRangeArgs, newUnsafeDestroyRangeResult, false),
		"RegisterLockObserver":   kitex.NewMethodInfo(registerLockObserverHandler, newRegisterLockObserverArgs, newRegisterLockObserverResult, false),
		"CheckLockObserver":      kitex.NewMethodInfo(checkLockObserverHandler, newCheckLockObserverArgs, newCheckLockObserverResult, false),
		"RemoveLockObserver":     kitex.NewMethodInfo(removeLockObserverHandler, newRemoveLockObserverArgs, newRemoveLockObserverResult, false),
		"PhysicalScanLock":       kitex.NewMethodInfo(physicalScanLockHandler, newPhysicalScanLockArgs, newPhysicalScanLockResult, false),
		"Coprocessor":            kitex.NewMethodInfo(coprocessorHandler, newCoprocessorArgs, newCoprocessorResult, false),
		"CoprocessorStream":      kitex.NewMethodInfo(coprocessorStreamHandler, newCoprocessorStreamArgs, newCoprocessorStreamResult, false),
		"BatchCoprocessor":       kitex.NewMethodInfo(batchCoprocessorHandler, newBatchCoprocessorArgs, newBatchCoprocessorResult, false),
		"RawCoprocessor":         kitex.NewMethodInfo(rawCoprocessorHandler, newRawCoprocessorArgs, newRawCoprocessorResult, false),
		"Raft":                   kitex.NewMethodInfo(raftHandler, newRaftArgs, newRaftResult, false),
		"BatchRaft":              kitex.NewMethodInfo(batchRaftHandler, newBatchRaftArgs, newBatchRaftResult, false),
		"Snapshot":               kitex.NewMethodInfo(snapshotHandler, newSnapshotArgs, newSnapshotResult, false),
		"SplitRegion":            kitex.NewMethodInfo(splitRegionHandler, newSplitRegionArgs, newSplitRegionResult, false),
		"ReadIndex":              kitex.NewMethodInfo(readIndexHandler, newReadIndexArgs, newReadIndexResult, false),
		"MvccGetByKey":           kitex.NewMethodInfo(mvccGetByKeyHandler, newMvccGetByKeyArgs, newMvccGetByKeyResult, false),
		"MvccGetByStartTs":       kitex.NewMethodInfo(mvccGetByStartTsHandler, newMvccGetByStartTsArgs, newMvccGetByStartTsResult, false),
		"BatchCommands":          kitex.NewMethodInfo(batchCommandsHandler, newBatchCommandsArgs, newBatchCommandsResult, false),
		"DispatchMPPTask":        kitex.NewMethodInfo(dispatchMPPTaskHandler, newDispatchMPPTaskArgs, newDispatchMPPTaskResult, false),
		"CancelMPPTask":          kitex.NewMethodInfo(cancelMPPTaskHandler, newCancelMPPTaskArgs, newCancelMPPTaskResult, false),
		"EstablishMPPConnection": kitex.NewMethodInfo(establishMPPConnectionHandler, newEstablishMPPConnectionArgs, newEstablishMPPConnectionResult, false),
		"IsAlive":                kitex.NewMethodInfo(isAliveHandler, newIsAliveArgs, newIsAliveResult, false),
		"CheckLeader":            kitex.NewMethodInfo(checkLeaderHandler, newCheckLeaderArgs, newCheckLeaderResult, false),
		"GetStoreSafeTS":         kitex.NewMethodInfo(getStoreSafeTSHandler, newGetStoreSafeTSArgs, newGetStoreSafeTSResult, false),
		"GetLockWaitInfo":        kitex.NewMethodInfo(getLockWaitInfoHandler, newGetLockWaitInfoArgs, newGetLockWaitInfoResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "tikvpb",
	}
	extra["streaming"] = true
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.1.2",
		Extra:           extra,
	}
	return svcInfo
}

func kvGetHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.GetRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvGet(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvGetArgs:
		success, err := handler.(tikvpb.Tikv).KvGet(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvGetResult)
		realResult.Success = success
	}
	return nil
}
func newKvGetArgs() interface{} {
	return &KvGetArgs{}
}

func newKvGetResult() interface{} {
	return &KvGetResult{}
}

type KvGetArgs struct {
	Req *kvrpcpb.GetRequest
}

func (p *KvGetArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvGetArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvGetArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.GetRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvGetArgs_Req_DEFAULT *kvrpcpb.GetRequest

func (p *KvGetArgs) GetReq() *kvrpcpb.GetRequest {
	if !p.IsSetReq() {
		return KvGetArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvGetArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvGetResult struct {
	Success *kvrpcpb.GetResponse
}

var KvGetResult_Success_DEFAULT *kvrpcpb.GetResponse

func (p *KvGetResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvGetResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvGetResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.GetResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvGetResult) GetSuccess() *kvrpcpb.GetResponse {
	if !p.IsSetSuccess() {
		return KvGetResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvGetResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.GetResponse)
}

func (p *KvGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvScanHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.ScanRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvScan(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvScanArgs:
		success, err := handler.(tikvpb.Tikv).KvScan(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvScanResult)
		realResult.Success = success
	}
	return nil
}
func newKvScanArgs() interface{} {
	return &KvScanArgs{}
}

func newKvScanResult() interface{} {
	return &KvScanResult{}
}

type KvScanArgs struct {
	Req *kvrpcpb.ScanRequest
}

func (p *KvScanArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvScanArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvScanArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ScanRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvScanArgs_Req_DEFAULT *kvrpcpb.ScanRequest

func (p *KvScanArgs) GetReq() *kvrpcpb.ScanRequest {
	if !p.IsSetReq() {
		return KvScanArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvScanArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvScanResult struct {
	Success *kvrpcpb.ScanResponse
}

var KvScanResult_Success_DEFAULT *kvrpcpb.ScanResponse

func (p *KvScanResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvScanResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvScanResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ScanResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvScanResult) GetSuccess() *kvrpcpb.ScanResponse {
	if !p.IsSetSuccess() {
		return KvScanResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvScanResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.ScanResponse)
}

func (p *KvScanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvPrewriteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.PrewriteRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvPrewrite(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvPrewriteArgs:
		success, err := handler.(tikvpb.Tikv).KvPrewrite(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvPrewriteResult)
		realResult.Success = success
	}
	return nil
}
func newKvPrewriteArgs() interface{} {
	return &KvPrewriteArgs{}
}

func newKvPrewriteResult() interface{} {
	return &KvPrewriteResult{}
}

type KvPrewriteArgs struct {
	Req *kvrpcpb.PrewriteRequest
}

func (p *KvPrewriteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvPrewriteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvPrewriteArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.PrewriteRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvPrewriteArgs_Req_DEFAULT *kvrpcpb.PrewriteRequest

func (p *KvPrewriteArgs) GetReq() *kvrpcpb.PrewriteRequest {
	if !p.IsSetReq() {
		return KvPrewriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvPrewriteArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvPrewriteResult struct {
	Success *kvrpcpb.PrewriteResponse
}

var KvPrewriteResult_Success_DEFAULT *kvrpcpb.PrewriteResponse

func (p *KvPrewriteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvPrewriteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvPrewriteResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.PrewriteResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvPrewriteResult) GetSuccess() *kvrpcpb.PrewriteResponse {
	if !p.IsSetSuccess() {
		return KvPrewriteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvPrewriteResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.PrewriteResponse)
}

func (p *KvPrewriteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvPessimisticLockHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.PessimisticLockRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvPessimisticLock(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvPessimisticLockArgs:
		success, err := handler.(tikvpb.Tikv).KvPessimisticLock(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvPessimisticLockResult)
		realResult.Success = success
	}
	return nil
}
func newKvPessimisticLockArgs() interface{} {
	return &KvPessimisticLockArgs{}
}

func newKvPessimisticLockResult() interface{} {
	return &KvPessimisticLockResult{}
}

type KvPessimisticLockArgs struct {
	Req *kvrpcpb.PessimisticLockRequest
}

func (p *KvPessimisticLockArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvPessimisticLockArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvPessimisticLockArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.PessimisticLockRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvPessimisticLockArgs_Req_DEFAULT *kvrpcpb.PessimisticLockRequest

func (p *KvPessimisticLockArgs) GetReq() *kvrpcpb.PessimisticLockRequest {
	if !p.IsSetReq() {
		return KvPessimisticLockArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvPessimisticLockArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvPessimisticLockResult struct {
	Success *kvrpcpb.PessimisticLockResponse
}

var KvPessimisticLockResult_Success_DEFAULT *kvrpcpb.PessimisticLockResponse

func (p *KvPessimisticLockResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvPessimisticLockResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvPessimisticLockResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.PessimisticLockResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvPessimisticLockResult) GetSuccess() *kvrpcpb.PessimisticLockResponse {
	if !p.IsSetSuccess() {
		return KvPessimisticLockResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvPessimisticLockResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.PessimisticLockResponse)
}

func (p *KvPessimisticLockResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kVPessimisticRollbackHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.PessimisticRollbackRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KVPessimisticRollback(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KVPessimisticRollbackArgs:
		success, err := handler.(tikvpb.Tikv).KVPessimisticRollback(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KVPessimisticRollbackResult)
		realResult.Success = success
	}
	return nil
}
func newKVPessimisticRollbackArgs() interface{} {
	return &KVPessimisticRollbackArgs{}
}

func newKVPessimisticRollbackResult() interface{} {
	return &KVPessimisticRollbackResult{}
}

type KVPessimisticRollbackArgs struct {
	Req *kvrpcpb.PessimisticRollbackRequest
}

func (p *KVPessimisticRollbackArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KVPessimisticRollbackArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KVPessimisticRollbackArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.PessimisticRollbackRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KVPessimisticRollbackArgs_Req_DEFAULT *kvrpcpb.PessimisticRollbackRequest

func (p *KVPessimisticRollbackArgs) GetReq() *kvrpcpb.PessimisticRollbackRequest {
	if !p.IsSetReq() {
		return KVPessimisticRollbackArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KVPessimisticRollbackArgs) IsSetReq() bool {
	return p.Req != nil
}

type KVPessimisticRollbackResult struct {
	Success *kvrpcpb.PessimisticRollbackResponse
}

var KVPessimisticRollbackResult_Success_DEFAULT *kvrpcpb.PessimisticRollbackResponse

func (p *KVPessimisticRollbackResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KVPessimisticRollbackResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KVPessimisticRollbackResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.PessimisticRollbackResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KVPessimisticRollbackResult) GetSuccess() *kvrpcpb.PessimisticRollbackResponse {
	if !p.IsSetSuccess() {
		return KVPessimisticRollbackResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KVPessimisticRollbackResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.PessimisticRollbackResponse)
}

func (p *KVPessimisticRollbackResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvTxnHeartBeatHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.TxnHeartBeatRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvTxnHeartBeat(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvTxnHeartBeatArgs:
		success, err := handler.(tikvpb.Tikv).KvTxnHeartBeat(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvTxnHeartBeatResult)
		realResult.Success = success
	}
	return nil
}
func newKvTxnHeartBeatArgs() interface{} {
	return &KvTxnHeartBeatArgs{}
}

func newKvTxnHeartBeatResult() interface{} {
	return &KvTxnHeartBeatResult{}
}

type KvTxnHeartBeatArgs struct {
	Req *kvrpcpb.TxnHeartBeatRequest
}

func (p *KvTxnHeartBeatArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvTxnHeartBeatArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvTxnHeartBeatArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.TxnHeartBeatRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvTxnHeartBeatArgs_Req_DEFAULT *kvrpcpb.TxnHeartBeatRequest

func (p *KvTxnHeartBeatArgs) GetReq() *kvrpcpb.TxnHeartBeatRequest {
	if !p.IsSetReq() {
		return KvTxnHeartBeatArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvTxnHeartBeatArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvTxnHeartBeatResult struct {
	Success *kvrpcpb.TxnHeartBeatResponse
}

var KvTxnHeartBeatResult_Success_DEFAULT *kvrpcpb.TxnHeartBeatResponse

func (p *KvTxnHeartBeatResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvTxnHeartBeatResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvTxnHeartBeatResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.TxnHeartBeatResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvTxnHeartBeatResult) GetSuccess() *kvrpcpb.TxnHeartBeatResponse {
	if !p.IsSetSuccess() {
		return KvTxnHeartBeatResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvTxnHeartBeatResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.TxnHeartBeatResponse)
}

func (p *KvTxnHeartBeatResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvCheckTxnStatusHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.CheckTxnStatusRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvCheckTxnStatus(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvCheckTxnStatusArgs:
		success, err := handler.(tikvpb.Tikv).KvCheckTxnStatus(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvCheckTxnStatusResult)
		realResult.Success = success
	}
	return nil
}
func newKvCheckTxnStatusArgs() interface{} {
	return &KvCheckTxnStatusArgs{}
}

func newKvCheckTxnStatusResult() interface{} {
	return &KvCheckTxnStatusResult{}
}

type KvCheckTxnStatusArgs struct {
	Req *kvrpcpb.CheckTxnStatusRequest
}

func (p *KvCheckTxnStatusArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvCheckTxnStatusArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvCheckTxnStatusArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CheckTxnStatusRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvCheckTxnStatusArgs_Req_DEFAULT *kvrpcpb.CheckTxnStatusRequest

func (p *KvCheckTxnStatusArgs) GetReq() *kvrpcpb.CheckTxnStatusRequest {
	if !p.IsSetReq() {
		return KvCheckTxnStatusArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvCheckTxnStatusArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvCheckTxnStatusResult struct {
	Success *kvrpcpb.CheckTxnStatusResponse
}

var KvCheckTxnStatusResult_Success_DEFAULT *kvrpcpb.CheckTxnStatusResponse

func (p *KvCheckTxnStatusResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvCheckTxnStatusResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvCheckTxnStatusResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CheckTxnStatusResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvCheckTxnStatusResult) GetSuccess() *kvrpcpb.CheckTxnStatusResponse {
	if !p.IsSetSuccess() {
		return KvCheckTxnStatusResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvCheckTxnStatusResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.CheckTxnStatusResponse)
}

func (p *KvCheckTxnStatusResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvCheckSecondaryLocksHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.CheckSecondaryLocksRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvCheckSecondaryLocks(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvCheckSecondaryLocksArgs:
		success, err := handler.(tikvpb.Tikv).KvCheckSecondaryLocks(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvCheckSecondaryLocksResult)
		realResult.Success = success
	}
	return nil
}
func newKvCheckSecondaryLocksArgs() interface{} {
	return &KvCheckSecondaryLocksArgs{}
}

func newKvCheckSecondaryLocksResult() interface{} {
	return &KvCheckSecondaryLocksResult{}
}

type KvCheckSecondaryLocksArgs struct {
	Req *kvrpcpb.CheckSecondaryLocksRequest
}

func (p *KvCheckSecondaryLocksArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvCheckSecondaryLocksArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvCheckSecondaryLocksArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CheckSecondaryLocksRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvCheckSecondaryLocksArgs_Req_DEFAULT *kvrpcpb.CheckSecondaryLocksRequest

func (p *KvCheckSecondaryLocksArgs) GetReq() *kvrpcpb.CheckSecondaryLocksRequest {
	if !p.IsSetReq() {
		return KvCheckSecondaryLocksArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvCheckSecondaryLocksArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvCheckSecondaryLocksResult struct {
	Success *kvrpcpb.CheckSecondaryLocksResponse
}

var KvCheckSecondaryLocksResult_Success_DEFAULT *kvrpcpb.CheckSecondaryLocksResponse

func (p *KvCheckSecondaryLocksResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvCheckSecondaryLocksResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvCheckSecondaryLocksResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CheckSecondaryLocksResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvCheckSecondaryLocksResult) GetSuccess() *kvrpcpb.CheckSecondaryLocksResponse {
	if !p.IsSetSuccess() {
		return KvCheckSecondaryLocksResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvCheckSecondaryLocksResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.CheckSecondaryLocksResponse)
}

func (p *KvCheckSecondaryLocksResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvCommitHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.CommitRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvCommit(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvCommitArgs:
		success, err := handler.(tikvpb.Tikv).KvCommit(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvCommitResult)
		realResult.Success = success
	}
	return nil
}
func newKvCommitArgs() interface{} {
	return &KvCommitArgs{}
}

func newKvCommitResult() interface{} {
	return &KvCommitResult{}
}

type KvCommitArgs struct {
	Req *kvrpcpb.CommitRequest
}

func (p *KvCommitArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvCommitArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvCommitArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CommitRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvCommitArgs_Req_DEFAULT *kvrpcpb.CommitRequest

func (p *KvCommitArgs) GetReq() *kvrpcpb.CommitRequest {
	if !p.IsSetReq() {
		return KvCommitArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvCommitArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvCommitResult struct {
	Success *kvrpcpb.CommitResponse
}

var KvCommitResult_Success_DEFAULT *kvrpcpb.CommitResponse

func (p *KvCommitResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvCommitResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvCommitResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CommitResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvCommitResult) GetSuccess() *kvrpcpb.CommitResponse {
	if !p.IsSetSuccess() {
		return KvCommitResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvCommitResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.CommitResponse)
}

func (p *KvCommitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvImportHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.ImportRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvImport(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvImportArgs:
		success, err := handler.(tikvpb.Tikv).KvImport(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvImportResult)
		realResult.Success = success
	}
	return nil
}
func newKvImportArgs() interface{} {
	return &KvImportArgs{}
}

func newKvImportResult() interface{} {
	return &KvImportResult{}
}

type KvImportArgs struct {
	Req *kvrpcpb.ImportRequest
}

func (p *KvImportArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvImportArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvImportArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ImportRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvImportArgs_Req_DEFAULT *kvrpcpb.ImportRequest

func (p *KvImportArgs) GetReq() *kvrpcpb.ImportRequest {
	if !p.IsSetReq() {
		return KvImportArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvImportArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvImportResult struct {
	Success *kvrpcpb.ImportResponse
}

var KvImportResult_Success_DEFAULT *kvrpcpb.ImportResponse

func (p *KvImportResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvImportResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvImportResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ImportResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvImportResult) GetSuccess() *kvrpcpb.ImportResponse {
	if !p.IsSetSuccess() {
		return KvImportResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvImportResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.ImportResponse)
}

func (p *KvImportResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvCleanupHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.CleanupRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvCleanup(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvCleanupArgs:
		success, err := handler.(tikvpb.Tikv).KvCleanup(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvCleanupResult)
		realResult.Success = success
	}
	return nil
}
func newKvCleanupArgs() interface{} {
	return &KvCleanupArgs{}
}

func newKvCleanupResult() interface{} {
	return &KvCleanupResult{}
}

type KvCleanupArgs struct {
	Req *kvrpcpb.CleanupRequest
}

func (p *KvCleanupArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvCleanupArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvCleanupArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CleanupRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvCleanupArgs_Req_DEFAULT *kvrpcpb.CleanupRequest

func (p *KvCleanupArgs) GetReq() *kvrpcpb.CleanupRequest {
	if !p.IsSetReq() {
		return KvCleanupArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvCleanupArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvCleanupResult struct {
	Success *kvrpcpb.CleanupResponse
}

var KvCleanupResult_Success_DEFAULT *kvrpcpb.CleanupResponse

func (p *KvCleanupResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvCleanupResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvCleanupResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CleanupResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvCleanupResult) GetSuccess() *kvrpcpb.CleanupResponse {
	if !p.IsSetSuccess() {
		return KvCleanupResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvCleanupResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.CleanupResponse)
}

func (p *KvCleanupResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvBatchGetHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.BatchGetRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvBatchGet(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvBatchGetArgs:
		success, err := handler.(tikvpb.Tikv).KvBatchGet(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvBatchGetResult)
		realResult.Success = success
	}
	return nil
}
func newKvBatchGetArgs() interface{} {
	return &KvBatchGetArgs{}
}

func newKvBatchGetResult() interface{} {
	return &KvBatchGetResult{}
}

type KvBatchGetArgs struct {
	Req *kvrpcpb.BatchGetRequest
}

func (p *KvBatchGetArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvBatchGetArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvBatchGetArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.BatchGetRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvBatchGetArgs_Req_DEFAULT *kvrpcpb.BatchGetRequest

func (p *KvBatchGetArgs) GetReq() *kvrpcpb.BatchGetRequest {
	if !p.IsSetReq() {
		return KvBatchGetArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvBatchGetArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvBatchGetResult struct {
	Success *kvrpcpb.BatchGetResponse
}

var KvBatchGetResult_Success_DEFAULT *kvrpcpb.BatchGetResponse

func (p *KvBatchGetResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvBatchGetResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvBatchGetResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.BatchGetResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvBatchGetResult) GetSuccess() *kvrpcpb.BatchGetResponse {
	if !p.IsSetSuccess() {
		return KvBatchGetResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvBatchGetResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.BatchGetResponse)
}

func (p *KvBatchGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvBatchRollbackHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.BatchRollbackRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvBatchRollback(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvBatchRollbackArgs:
		success, err := handler.(tikvpb.Tikv).KvBatchRollback(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvBatchRollbackResult)
		realResult.Success = success
	}
	return nil
}
func newKvBatchRollbackArgs() interface{} {
	return &KvBatchRollbackArgs{}
}

func newKvBatchRollbackResult() interface{} {
	return &KvBatchRollbackResult{}
}

type KvBatchRollbackArgs struct {
	Req *kvrpcpb.BatchRollbackRequest
}

func (p *KvBatchRollbackArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvBatchRollbackArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvBatchRollbackArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.BatchRollbackRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvBatchRollbackArgs_Req_DEFAULT *kvrpcpb.BatchRollbackRequest

func (p *KvBatchRollbackArgs) GetReq() *kvrpcpb.BatchRollbackRequest {
	if !p.IsSetReq() {
		return KvBatchRollbackArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvBatchRollbackArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvBatchRollbackResult struct {
	Success *kvrpcpb.BatchRollbackResponse
}

var KvBatchRollbackResult_Success_DEFAULT *kvrpcpb.BatchRollbackResponse

func (p *KvBatchRollbackResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvBatchRollbackResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvBatchRollbackResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.BatchRollbackResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvBatchRollbackResult) GetSuccess() *kvrpcpb.BatchRollbackResponse {
	if !p.IsSetSuccess() {
		return KvBatchRollbackResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvBatchRollbackResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.BatchRollbackResponse)
}

func (p *KvBatchRollbackResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvScanLockHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.ScanLockRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvScanLock(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvScanLockArgs:
		success, err := handler.(tikvpb.Tikv).KvScanLock(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvScanLockResult)
		realResult.Success = success
	}
	return nil
}
func newKvScanLockArgs() interface{} {
	return &KvScanLockArgs{}
}

func newKvScanLockResult() interface{} {
	return &KvScanLockResult{}
}

type KvScanLockArgs struct {
	Req *kvrpcpb.ScanLockRequest
}

func (p *KvScanLockArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvScanLockArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvScanLockArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ScanLockRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvScanLockArgs_Req_DEFAULT *kvrpcpb.ScanLockRequest

func (p *KvScanLockArgs) GetReq() *kvrpcpb.ScanLockRequest {
	if !p.IsSetReq() {
		return KvScanLockArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvScanLockArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvScanLockResult struct {
	Success *kvrpcpb.ScanLockResponse
}

var KvScanLockResult_Success_DEFAULT *kvrpcpb.ScanLockResponse

func (p *KvScanLockResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvScanLockResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvScanLockResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ScanLockResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvScanLockResult) GetSuccess() *kvrpcpb.ScanLockResponse {
	if !p.IsSetSuccess() {
		return KvScanLockResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvScanLockResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.ScanLockResponse)
}

func (p *KvScanLockResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvResolveLockHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.ResolveLockRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvResolveLock(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvResolveLockArgs:
		success, err := handler.(tikvpb.Tikv).KvResolveLock(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvResolveLockResult)
		realResult.Success = success
	}
	return nil
}
func newKvResolveLockArgs() interface{} {
	return &KvResolveLockArgs{}
}

func newKvResolveLockResult() interface{} {
	return &KvResolveLockResult{}
}

type KvResolveLockArgs struct {
	Req *kvrpcpb.ResolveLockRequest
}

func (p *KvResolveLockArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvResolveLockArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvResolveLockArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ResolveLockRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvResolveLockArgs_Req_DEFAULT *kvrpcpb.ResolveLockRequest

func (p *KvResolveLockArgs) GetReq() *kvrpcpb.ResolveLockRequest {
	if !p.IsSetReq() {
		return KvResolveLockArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvResolveLockArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvResolveLockResult struct {
	Success *kvrpcpb.ResolveLockResponse
}

var KvResolveLockResult_Success_DEFAULT *kvrpcpb.ResolveLockResponse

func (p *KvResolveLockResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvResolveLockResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvResolveLockResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ResolveLockResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvResolveLockResult) GetSuccess() *kvrpcpb.ResolveLockResponse {
	if !p.IsSetSuccess() {
		return KvResolveLockResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvResolveLockResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.ResolveLockResponse)
}

func (p *KvResolveLockResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvGCHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.GCRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvGC(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvGCArgs:
		success, err := handler.(tikvpb.Tikv).KvGC(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvGCResult)
		realResult.Success = success
	}
	return nil
}
func newKvGCArgs() interface{} {
	return &KvGCArgs{}
}

func newKvGCResult() interface{} {
	return &KvGCResult{}
}

type KvGCArgs struct {
	Req *kvrpcpb.GCRequest
}

func (p *KvGCArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvGCArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvGCArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.GCRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvGCArgs_Req_DEFAULT *kvrpcpb.GCRequest

func (p *KvGCArgs) GetReq() *kvrpcpb.GCRequest {
	if !p.IsSetReq() {
		return KvGCArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvGCArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvGCResult struct {
	Success *kvrpcpb.GCResponse
}

var KvGCResult_Success_DEFAULT *kvrpcpb.GCResponse

func (p *KvGCResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvGCResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvGCResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.GCResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvGCResult) GetSuccess() *kvrpcpb.GCResponse {
	if !p.IsSetSuccess() {
		return KvGCResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvGCResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.GCResponse)
}

func (p *KvGCResult) IsSetSuccess() bool {
	return p.Success != nil
}

func kvDeleteRangeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.DeleteRangeRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).KvDeleteRange(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *KvDeleteRangeArgs:
		success, err := handler.(tikvpb.Tikv).KvDeleteRange(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*KvDeleteRangeResult)
		realResult.Success = success
	}
	return nil
}
func newKvDeleteRangeArgs() interface{} {
	return &KvDeleteRangeArgs{}
}

func newKvDeleteRangeResult() interface{} {
	return &KvDeleteRangeResult{}
}

type KvDeleteRangeArgs struct {
	Req *kvrpcpb.DeleteRangeRequest
}

func (p *KvDeleteRangeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in KvDeleteRangeArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *KvDeleteRangeArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.DeleteRangeRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var KvDeleteRangeArgs_Req_DEFAULT *kvrpcpb.DeleteRangeRequest

func (p *KvDeleteRangeArgs) GetReq() *kvrpcpb.DeleteRangeRequest {
	if !p.IsSetReq() {
		return KvDeleteRangeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *KvDeleteRangeArgs) IsSetReq() bool {
	return p.Req != nil
}

type KvDeleteRangeResult struct {
	Success *kvrpcpb.DeleteRangeResponse
}

var KvDeleteRangeResult_Success_DEFAULT *kvrpcpb.DeleteRangeResponse

func (p *KvDeleteRangeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in KvDeleteRangeResult")
	}
	return proto.Marshal(p.Success)
}

func (p *KvDeleteRangeResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.DeleteRangeResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *KvDeleteRangeResult) GetSuccess() *kvrpcpb.DeleteRangeResponse {
	if !p.IsSetSuccess() {
		return KvDeleteRangeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *KvDeleteRangeResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.DeleteRangeResponse)
}

func (p *KvDeleteRangeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawGetHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawGetRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawGet(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawGetArgs:
		success, err := handler.(tikvpb.Tikv).RawGet(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawGetResult)
		realResult.Success = success
	}
	return nil
}
func newRawGetArgs() interface{} {
	return &RawGetArgs{}
}

func newRawGetResult() interface{} {
	return &RawGetResult{}
}

type RawGetArgs struct {
	Req *kvrpcpb.RawGetRequest
}

func (p *RawGetArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawGetArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawGetArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawGetRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawGetArgs_Req_DEFAULT *kvrpcpb.RawGetRequest

func (p *RawGetArgs) GetReq() *kvrpcpb.RawGetRequest {
	if !p.IsSetReq() {
		return RawGetArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawGetArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawGetResult struct {
	Success *kvrpcpb.RawGetResponse
}

var RawGetResult_Success_DEFAULT *kvrpcpb.RawGetResponse

func (p *RawGetResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawGetResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawGetResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawGetResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawGetResult) GetSuccess() *kvrpcpb.RawGetResponse {
	if !p.IsSetSuccess() {
		return RawGetResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawGetResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawGetResponse)
}

func (p *RawGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawBatchGetHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawBatchGetRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawBatchGet(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawBatchGetArgs:
		success, err := handler.(tikvpb.Tikv).RawBatchGet(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawBatchGetResult)
		realResult.Success = success
	}
	return nil
}
func newRawBatchGetArgs() interface{} {
	return &RawBatchGetArgs{}
}

func newRawBatchGetResult() interface{} {
	return &RawBatchGetResult{}
}

type RawBatchGetArgs struct {
	Req *kvrpcpb.RawBatchGetRequest
}

func (p *RawBatchGetArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawBatchGetArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawBatchGetArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawBatchGetRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawBatchGetArgs_Req_DEFAULT *kvrpcpb.RawBatchGetRequest

func (p *RawBatchGetArgs) GetReq() *kvrpcpb.RawBatchGetRequest {
	if !p.IsSetReq() {
		return RawBatchGetArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawBatchGetArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawBatchGetResult struct {
	Success *kvrpcpb.RawBatchGetResponse
}

var RawBatchGetResult_Success_DEFAULT *kvrpcpb.RawBatchGetResponse

func (p *RawBatchGetResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawBatchGetResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawBatchGetResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawBatchGetResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawBatchGetResult) GetSuccess() *kvrpcpb.RawBatchGetResponse {
	if !p.IsSetSuccess() {
		return RawBatchGetResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawBatchGetResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawBatchGetResponse)
}

func (p *RawBatchGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawPutHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawPutRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawPut(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawPutArgs:
		success, err := handler.(tikvpb.Tikv).RawPut(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawPutResult)
		realResult.Success = success
	}
	return nil
}
func newRawPutArgs() interface{} {
	return &RawPutArgs{}
}

func newRawPutResult() interface{} {
	return &RawPutResult{}
}

type RawPutArgs struct {
	Req *kvrpcpb.RawPutRequest
}

func (p *RawPutArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawPutArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawPutArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawPutRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawPutArgs_Req_DEFAULT *kvrpcpb.RawPutRequest

func (p *RawPutArgs) GetReq() *kvrpcpb.RawPutRequest {
	if !p.IsSetReq() {
		return RawPutArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawPutArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawPutResult struct {
	Success *kvrpcpb.RawPutResponse
}

var RawPutResult_Success_DEFAULT *kvrpcpb.RawPutResponse

func (p *RawPutResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawPutResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawPutResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawPutResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawPutResult) GetSuccess() *kvrpcpb.RawPutResponse {
	if !p.IsSetSuccess() {
		return RawPutResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawPutResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawPutResponse)
}

func (p *RawPutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawBatchPutHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawBatchPutRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawBatchPut(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawBatchPutArgs:
		success, err := handler.(tikvpb.Tikv).RawBatchPut(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawBatchPutResult)
		realResult.Success = success
	}
	return nil
}
func newRawBatchPutArgs() interface{} {
	return &RawBatchPutArgs{}
}

func newRawBatchPutResult() interface{} {
	return &RawBatchPutResult{}
}

type RawBatchPutArgs struct {
	Req *kvrpcpb.RawBatchPutRequest
}

func (p *RawBatchPutArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawBatchPutArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawBatchPutArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawBatchPutRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawBatchPutArgs_Req_DEFAULT *kvrpcpb.RawBatchPutRequest

func (p *RawBatchPutArgs) GetReq() *kvrpcpb.RawBatchPutRequest {
	if !p.IsSetReq() {
		return RawBatchPutArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawBatchPutArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawBatchPutResult struct {
	Success *kvrpcpb.RawBatchPutResponse
}

var RawBatchPutResult_Success_DEFAULT *kvrpcpb.RawBatchPutResponse

func (p *RawBatchPutResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawBatchPutResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawBatchPutResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawBatchPutResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawBatchPutResult) GetSuccess() *kvrpcpb.RawBatchPutResponse {
	if !p.IsSetSuccess() {
		return RawBatchPutResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawBatchPutResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawBatchPutResponse)
}

func (p *RawBatchPutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawDeleteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawDeleteRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawDelete(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawDeleteArgs:
		success, err := handler.(tikvpb.Tikv).RawDelete(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawDeleteResult)
		realResult.Success = success
	}
	return nil
}
func newRawDeleteArgs() interface{} {
	return &RawDeleteArgs{}
}

func newRawDeleteResult() interface{} {
	return &RawDeleteResult{}
}

type RawDeleteArgs struct {
	Req *kvrpcpb.RawDeleteRequest
}

func (p *RawDeleteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawDeleteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawDeleteArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawDeleteRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawDeleteArgs_Req_DEFAULT *kvrpcpb.RawDeleteRequest

func (p *RawDeleteArgs) GetReq() *kvrpcpb.RawDeleteRequest {
	if !p.IsSetReq() {
		return RawDeleteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawDeleteArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawDeleteResult struct {
	Success *kvrpcpb.RawDeleteResponse
}

var RawDeleteResult_Success_DEFAULT *kvrpcpb.RawDeleteResponse

func (p *RawDeleteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawDeleteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawDeleteResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawDeleteResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawDeleteResult) GetSuccess() *kvrpcpb.RawDeleteResponse {
	if !p.IsSetSuccess() {
		return RawDeleteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawDeleteResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawDeleteResponse)
}

func (p *RawDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawBatchDeleteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawBatchDeleteRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawBatchDelete(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawBatchDeleteArgs:
		success, err := handler.(tikvpb.Tikv).RawBatchDelete(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawBatchDeleteResult)
		realResult.Success = success
	}
	return nil
}
func newRawBatchDeleteArgs() interface{} {
	return &RawBatchDeleteArgs{}
}

func newRawBatchDeleteResult() interface{} {
	return &RawBatchDeleteResult{}
}

type RawBatchDeleteArgs struct {
	Req *kvrpcpb.RawBatchDeleteRequest
}

func (p *RawBatchDeleteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawBatchDeleteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawBatchDeleteArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawBatchDeleteRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawBatchDeleteArgs_Req_DEFAULT *kvrpcpb.RawBatchDeleteRequest

func (p *RawBatchDeleteArgs) GetReq() *kvrpcpb.RawBatchDeleteRequest {
	if !p.IsSetReq() {
		return RawBatchDeleteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawBatchDeleteArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawBatchDeleteResult struct {
	Success *kvrpcpb.RawBatchDeleteResponse
}

var RawBatchDeleteResult_Success_DEFAULT *kvrpcpb.RawBatchDeleteResponse

func (p *RawBatchDeleteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawBatchDeleteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawBatchDeleteResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawBatchDeleteResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawBatchDeleteResult) GetSuccess() *kvrpcpb.RawBatchDeleteResponse {
	if !p.IsSetSuccess() {
		return RawBatchDeleteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawBatchDeleteResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawBatchDeleteResponse)
}

func (p *RawBatchDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawScanHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawScanRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawScan(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawScanArgs:
		success, err := handler.(tikvpb.Tikv).RawScan(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawScanResult)
		realResult.Success = success
	}
	return nil
}
func newRawScanArgs() interface{} {
	return &RawScanArgs{}
}

func newRawScanResult() interface{} {
	return &RawScanResult{}
}

type RawScanArgs struct {
	Req *kvrpcpb.RawScanRequest
}

func (p *RawScanArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawScanArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawScanArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawScanRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawScanArgs_Req_DEFAULT *kvrpcpb.RawScanRequest

func (p *RawScanArgs) GetReq() *kvrpcpb.RawScanRequest {
	if !p.IsSetReq() {
		return RawScanArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawScanArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawScanResult struct {
	Success *kvrpcpb.RawScanResponse
}

var RawScanResult_Success_DEFAULT *kvrpcpb.RawScanResponse

func (p *RawScanResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawScanResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawScanResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawScanResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawScanResult) GetSuccess() *kvrpcpb.RawScanResponse {
	if !p.IsSetSuccess() {
		return RawScanResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawScanResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawScanResponse)
}

func (p *RawScanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawDeleteRangeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawDeleteRangeRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawDeleteRange(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawDeleteRangeArgs:
		success, err := handler.(tikvpb.Tikv).RawDeleteRange(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawDeleteRangeResult)
		realResult.Success = success
	}
	return nil
}
func newRawDeleteRangeArgs() interface{} {
	return &RawDeleteRangeArgs{}
}

func newRawDeleteRangeResult() interface{} {
	return &RawDeleteRangeResult{}
}

type RawDeleteRangeArgs struct {
	Req *kvrpcpb.RawDeleteRangeRequest
}

func (p *RawDeleteRangeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawDeleteRangeArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawDeleteRangeArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawDeleteRangeRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawDeleteRangeArgs_Req_DEFAULT *kvrpcpb.RawDeleteRangeRequest

func (p *RawDeleteRangeArgs) GetReq() *kvrpcpb.RawDeleteRangeRequest {
	if !p.IsSetReq() {
		return RawDeleteRangeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawDeleteRangeArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawDeleteRangeResult struct {
	Success *kvrpcpb.RawDeleteRangeResponse
}

var RawDeleteRangeResult_Success_DEFAULT *kvrpcpb.RawDeleteRangeResponse

func (p *RawDeleteRangeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawDeleteRangeResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawDeleteRangeResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawDeleteRangeResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawDeleteRangeResult) GetSuccess() *kvrpcpb.RawDeleteRangeResponse {
	if !p.IsSetSuccess() {
		return RawDeleteRangeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawDeleteRangeResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawDeleteRangeResponse)
}

func (p *RawDeleteRangeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawBatchScanHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawBatchScanRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawBatchScan(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawBatchScanArgs:
		success, err := handler.(tikvpb.Tikv).RawBatchScan(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawBatchScanResult)
		realResult.Success = success
	}
	return nil
}
func newRawBatchScanArgs() interface{} {
	return &RawBatchScanArgs{}
}

func newRawBatchScanResult() interface{} {
	return &RawBatchScanResult{}
}

type RawBatchScanArgs struct {
	Req *kvrpcpb.RawBatchScanRequest
}

func (p *RawBatchScanArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawBatchScanArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawBatchScanArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawBatchScanRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawBatchScanArgs_Req_DEFAULT *kvrpcpb.RawBatchScanRequest

func (p *RawBatchScanArgs) GetReq() *kvrpcpb.RawBatchScanRequest {
	if !p.IsSetReq() {
		return RawBatchScanArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawBatchScanArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawBatchScanResult struct {
	Success *kvrpcpb.RawBatchScanResponse
}

var RawBatchScanResult_Success_DEFAULT *kvrpcpb.RawBatchScanResponse

func (p *RawBatchScanResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawBatchScanResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawBatchScanResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawBatchScanResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawBatchScanResult) GetSuccess() *kvrpcpb.RawBatchScanResponse {
	if !p.IsSetSuccess() {
		return RawBatchScanResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawBatchScanResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawBatchScanResponse)
}

func (p *RawBatchScanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawGetKeyTTLHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawGetKeyTTLRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawGetKeyTTL(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawGetKeyTTLArgs:
		success, err := handler.(tikvpb.Tikv).RawGetKeyTTL(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawGetKeyTTLResult)
		realResult.Success = success
	}
	return nil
}
func newRawGetKeyTTLArgs() interface{} {
	return &RawGetKeyTTLArgs{}
}

func newRawGetKeyTTLResult() interface{} {
	return &RawGetKeyTTLResult{}
}

type RawGetKeyTTLArgs struct {
	Req *kvrpcpb.RawGetKeyTTLRequest
}

func (p *RawGetKeyTTLArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawGetKeyTTLArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawGetKeyTTLArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawGetKeyTTLRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawGetKeyTTLArgs_Req_DEFAULT *kvrpcpb.RawGetKeyTTLRequest

func (p *RawGetKeyTTLArgs) GetReq() *kvrpcpb.RawGetKeyTTLRequest {
	if !p.IsSetReq() {
		return RawGetKeyTTLArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawGetKeyTTLArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawGetKeyTTLResult struct {
	Success *kvrpcpb.RawGetKeyTTLResponse
}

var RawGetKeyTTLResult_Success_DEFAULT *kvrpcpb.RawGetKeyTTLResponse

func (p *RawGetKeyTTLResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawGetKeyTTLResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawGetKeyTTLResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawGetKeyTTLResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawGetKeyTTLResult) GetSuccess() *kvrpcpb.RawGetKeyTTLResponse {
	if !p.IsSetSuccess() {
		return RawGetKeyTTLResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawGetKeyTTLResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawGetKeyTTLResponse)
}

func (p *RawGetKeyTTLResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawCompareAndSwapHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawCASRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawCompareAndSwap(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawCompareAndSwapArgs:
		success, err := handler.(tikvpb.Tikv).RawCompareAndSwap(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawCompareAndSwapResult)
		realResult.Success = success
	}
	return nil
}
func newRawCompareAndSwapArgs() interface{} {
	return &RawCompareAndSwapArgs{}
}

func newRawCompareAndSwapResult() interface{} {
	return &RawCompareAndSwapResult{}
}

type RawCompareAndSwapArgs struct {
	Req *kvrpcpb.RawCASRequest
}

func (p *RawCompareAndSwapArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawCompareAndSwapArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawCompareAndSwapArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawCASRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawCompareAndSwapArgs_Req_DEFAULT *kvrpcpb.RawCASRequest

func (p *RawCompareAndSwapArgs) GetReq() *kvrpcpb.RawCASRequest {
	if !p.IsSetReq() {
		return RawCompareAndSwapArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawCompareAndSwapArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawCompareAndSwapResult struct {
	Success *kvrpcpb.RawCASResponse
}

var RawCompareAndSwapResult_Success_DEFAULT *kvrpcpb.RawCASResponse

func (p *RawCompareAndSwapResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawCompareAndSwapResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawCompareAndSwapResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawCASResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawCompareAndSwapResult) GetSuccess() *kvrpcpb.RawCASResponse {
	if !p.IsSetSuccess() {
		return RawCompareAndSwapResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawCompareAndSwapResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawCASResponse)
}

func (p *RawCompareAndSwapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawChecksumHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawChecksumRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawChecksum(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawChecksumArgs:
		success, err := handler.(tikvpb.Tikv).RawChecksum(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawChecksumResult)
		realResult.Success = success
	}
	return nil
}
func newRawChecksumArgs() interface{} {
	return &RawChecksumArgs{}
}

func newRawChecksumResult() interface{} {
	return &RawChecksumResult{}
}

type RawChecksumArgs struct {
	Req *kvrpcpb.RawChecksumRequest
}

func (p *RawChecksumArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawChecksumArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawChecksumArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawChecksumRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawChecksumArgs_Req_DEFAULT *kvrpcpb.RawChecksumRequest

func (p *RawChecksumArgs) GetReq() *kvrpcpb.RawChecksumRequest {
	if !p.IsSetReq() {
		return RawChecksumArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawChecksumArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawChecksumResult struct {
	Success *kvrpcpb.RawChecksumResponse
}

var RawChecksumResult_Success_DEFAULT *kvrpcpb.RawChecksumResponse

func (p *RawChecksumResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawChecksumResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawChecksumResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawChecksumResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawChecksumResult) GetSuccess() *kvrpcpb.RawChecksumResponse {
	if !p.IsSetSuccess() {
		return RawChecksumResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawChecksumResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawChecksumResponse)
}

func (p *RawChecksumResult) IsSetSuccess() bool {
	return p.Success != nil
}

func unsafeDestroyRangeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.UnsafeDestroyRangeRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).UnsafeDestroyRange(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UnsafeDestroyRangeArgs:
		success, err := handler.(tikvpb.Tikv).UnsafeDestroyRange(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UnsafeDestroyRangeResult)
		realResult.Success = success
	}
	return nil
}
func newUnsafeDestroyRangeArgs() interface{} {
	return &UnsafeDestroyRangeArgs{}
}

func newUnsafeDestroyRangeResult() interface{} {
	return &UnsafeDestroyRangeResult{}
}

type UnsafeDestroyRangeArgs struct {
	Req *kvrpcpb.UnsafeDestroyRangeRequest
}

func (p *UnsafeDestroyRangeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UnsafeDestroyRangeArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UnsafeDestroyRangeArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.UnsafeDestroyRangeRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UnsafeDestroyRangeArgs_Req_DEFAULT *kvrpcpb.UnsafeDestroyRangeRequest

func (p *UnsafeDestroyRangeArgs) GetReq() *kvrpcpb.UnsafeDestroyRangeRequest {
	if !p.IsSetReq() {
		return UnsafeDestroyRangeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UnsafeDestroyRangeArgs) IsSetReq() bool {
	return p.Req != nil
}

type UnsafeDestroyRangeResult struct {
	Success *kvrpcpb.UnsafeDestroyRangeResponse
}

var UnsafeDestroyRangeResult_Success_DEFAULT *kvrpcpb.UnsafeDestroyRangeResponse

func (p *UnsafeDestroyRangeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UnsafeDestroyRangeResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UnsafeDestroyRangeResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.UnsafeDestroyRangeResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UnsafeDestroyRangeResult) GetSuccess() *kvrpcpb.UnsafeDestroyRangeResponse {
	if !p.IsSetSuccess() {
		return UnsafeDestroyRangeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UnsafeDestroyRangeResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.UnsafeDestroyRangeResponse)
}

func (p *UnsafeDestroyRangeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func registerLockObserverHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RegisterLockObserverRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RegisterLockObserver(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RegisterLockObserverArgs:
		success, err := handler.(tikvpb.Tikv).RegisterLockObserver(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RegisterLockObserverResult)
		realResult.Success = success
	}
	return nil
}
func newRegisterLockObserverArgs() interface{} {
	return &RegisterLockObserverArgs{}
}

func newRegisterLockObserverResult() interface{} {
	return &RegisterLockObserverResult{}
}

type RegisterLockObserverArgs struct {
	Req *kvrpcpb.RegisterLockObserverRequest
}

func (p *RegisterLockObserverArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RegisterLockObserverArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RegisterLockObserverArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RegisterLockObserverRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RegisterLockObserverArgs_Req_DEFAULT *kvrpcpb.RegisterLockObserverRequest

func (p *RegisterLockObserverArgs) GetReq() *kvrpcpb.RegisterLockObserverRequest {
	if !p.IsSetReq() {
		return RegisterLockObserverArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RegisterLockObserverArgs) IsSetReq() bool {
	return p.Req != nil
}

type RegisterLockObserverResult struct {
	Success *kvrpcpb.RegisterLockObserverResponse
}

var RegisterLockObserverResult_Success_DEFAULT *kvrpcpb.RegisterLockObserverResponse

func (p *RegisterLockObserverResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RegisterLockObserverResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RegisterLockObserverResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RegisterLockObserverResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RegisterLockObserverResult) GetSuccess() *kvrpcpb.RegisterLockObserverResponse {
	if !p.IsSetSuccess() {
		return RegisterLockObserverResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RegisterLockObserverResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RegisterLockObserverResponse)
}

func (p *RegisterLockObserverResult) IsSetSuccess() bool {
	return p.Success != nil
}

func checkLockObserverHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.CheckLockObserverRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).CheckLockObserver(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CheckLockObserverArgs:
		success, err := handler.(tikvpb.Tikv).CheckLockObserver(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CheckLockObserverResult)
		realResult.Success = success
	}
	return nil
}
func newCheckLockObserverArgs() interface{} {
	return &CheckLockObserverArgs{}
}

func newCheckLockObserverResult() interface{} {
	return &CheckLockObserverResult{}
}

type CheckLockObserverArgs struct {
	Req *kvrpcpb.CheckLockObserverRequest
}

func (p *CheckLockObserverArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CheckLockObserverArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CheckLockObserverArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CheckLockObserverRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CheckLockObserverArgs_Req_DEFAULT *kvrpcpb.CheckLockObserverRequest

func (p *CheckLockObserverArgs) GetReq() *kvrpcpb.CheckLockObserverRequest {
	if !p.IsSetReq() {
		return CheckLockObserverArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CheckLockObserverArgs) IsSetReq() bool {
	return p.Req != nil
}

type CheckLockObserverResult struct {
	Success *kvrpcpb.CheckLockObserverResponse
}

var CheckLockObserverResult_Success_DEFAULT *kvrpcpb.CheckLockObserverResponse

func (p *CheckLockObserverResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CheckLockObserverResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CheckLockObserverResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CheckLockObserverResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CheckLockObserverResult) GetSuccess() *kvrpcpb.CheckLockObserverResponse {
	if !p.IsSetSuccess() {
		return CheckLockObserverResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CheckLockObserverResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.CheckLockObserverResponse)
}

func (p *CheckLockObserverResult) IsSetSuccess() bool {
	return p.Success != nil
}

func removeLockObserverHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RemoveLockObserverRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RemoveLockObserver(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RemoveLockObserverArgs:
		success, err := handler.(tikvpb.Tikv).RemoveLockObserver(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RemoveLockObserverResult)
		realResult.Success = success
	}
	return nil
}
func newRemoveLockObserverArgs() interface{} {
	return &RemoveLockObserverArgs{}
}

func newRemoveLockObserverResult() interface{} {
	return &RemoveLockObserverResult{}
}

type RemoveLockObserverArgs struct {
	Req *kvrpcpb.RemoveLockObserverRequest
}

func (p *RemoveLockObserverArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RemoveLockObserverArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RemoveLockObserverArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RemoveLockObserverRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RemoveLockObserverArgs_Req_DEFAULT *kvrpcpb.RemoveLockObserverRequest

func (p *RemoveLockObserverArgs) GetReq() *kvrpcpb.RemoveLockObserverRequest {
	if !p.IsSetReq() {
		return RemoveLockObserverArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RemoveLockObserverArgs) IsSetReq() bool {
	return p.Req != nil
}

type RemoveLockObserverResult struct {
	Success *kvrpcpb.RemoveLockObserverResponse
}

var RemoveLockObserverResult_Success_DEFAULT *kvrpcpb.RemoveLockObserverResponse

func (p *RemoveLockObserverResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RemoveLockObserverResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RemoveLockObserverResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RemoveLockObserverResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RemoveLockObserverResult) GetSuccess() *kvrpcpb.RemoveLockObserverResponse {
	if !p.IsSetSuccess() {
		return RemoveLockObserverResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RemoveLockObserverResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RemoveLockObserverResponse)
}

func (p *RemoveLockObserverResult) IsSetSuccess() bool {
	return p.Success != nil
}

func physicalScanLockHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.PhysicalScanLockRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).PhysicalScanLock(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *PhysicalScanLockArgs:
		success, err := handler.(tikvpb.Tikv).PhysicalScanLock(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PhysicalScanLockResult)
		realResult.Success = success
	}
	return nil
}
func newPhysicalScanLockArgs() interface{} {
	return &PhysicalScanLockArgs{}
}

func newPhysicalScanLockResult() interface{} {
	return &PhysicalScanLockResult{}
}

type PhysicalScanLockArgs struct {
	Req *kvrpcpb.PhysicalScanLockRequest
}

func (p *PhysicalScanLockArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in PhysicalScanLockArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *PhysicalScanLockArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.PhysicalScanLockRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PhysicalScanLockArgs_Req_DEFAULT *kvrpcpb.PhysicalScanLockRequest

func (p *PhysicalScanLockArgs) GetReq() *kvrpcpb.PhysicalScanLockRequest {
	if !p.IsSetReq() {
		return PhysicalScanLockArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PhysicalScanLockArgs) IsSetReq() bool {
	return p.Req != nil
}

type PhysicalScanLockResult struct {
	Success *kvrpcpb.PhysicalScanLockResponse
}

var PhysicalScanLockResult_Success_DEFAULT *kvrpcpb.PhysicalScanLockResponse

func (p *PhysicalScanLockResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in PhysicalScanLockResult")
	}
	return proto.Marshal(p.Success)
}

func (p *PhysicalScanLockResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.PhysicalScanLockResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PhysicalScanLockResult) GetSuccess() *kvrpcpb.PhysicalScanLockResponse {
	if !p.IsSetSuccess() {
		return PhysicalScanLockResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PhysicalScanLockResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.PhysicalScanLockResponse)
}

func (p *PhysicalScanLockResult) IsSetSuccess() bool {
	return p.Success != nil
}

func coprocessorHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(coprocessor.Request)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).Coprocessor(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CoprocessorArgs:
		success, err := handler.(tikvpb.Tikv).Coprocessor(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CoprocessorResult)
		realResult.Success = success
	}
	return nil
}
func newCoprocessorArgs() interface{} {
	return &CoprocessorArgs{}
}

func newCoprocessorResult() interface{} {
	return &CoprocessorResult{}
}

type CoprocessorArgs struct {
	Req *coprocessor.Request
}

func (p *CoprocessorArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CoprocessorArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CoprocessorArgs) Unmarshal(in []byte) error {
	msg := new(coprocessor.Request)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CoprocessorArgs_Req_DEFAULT *coprocessor.Request

func (p *CoprocessorArgs) GetReq() *coprocessor.Request {
	if !p.IsSetReq() {
		return CoprocessorArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CoprocessorArgs) IsSetReq() bool {
	return p.Req != nil
}

type CoprocessorResult struct {
	Success *coprocessor.Response
}

var CoprocessorResult_Success_DEFAULT *coprocessor.Response

func (p *CoprocessorResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CoprocessorResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CoprocessorResult) Unmarshal(in []byte) error {
	msg := new(coprocessor.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CoprocessorResult) GetSuccess() *coprocessor.Response {
	if !p.IsSetSuccess() {
		return CoprocessorResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CoprocessorResult) SetSuccess(x interface{}) {
	p.Success = x.(*coprocessor.Response)
}

func (p *CoprocessorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func coprocessorStreamHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &tikvCoprocessorStreamServer{st}
	req := new(coprocessor.Request)
	if err := st.RecvMsg(req); err != nil {
		return err
	}
	return handler.(tikvpb.Tikv).CoprocessorStream(req, stream)
}

type tikvCoprocessorStreamClient struct {
	streaming.Stream
}

func (x *tikvCoprocessorStreamClient) Recv() (*coprocessor.Response, error) {
	m := new(coprocessor.Response)
	return m, x.Stream.RecvMsg(m)
}

type tikvCoprocessorStreamServer struct {
	streaming.Stream
}

func (x *tikvCoprocessorStreamServer) Send(m *coprocessor.Response) error {
	return x.Stream.SendMsg(m)
}

func newCoprocessorStreamArgs() interface{} {
	return &CoprocessorStreamArgs{}
}

func newCoprocessorStreamResult() interface{} {
	return &CoprocessorStreamResult{}
}

type CoprocessorStreamArgs struct {
	Req *coprocessor.Request
}

func (p *CoprocessorStreamArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CoprocessorStreamArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CoprocessorStreamArgs) Unmarshal(in []byte) error {
	msg := new(coprocessor.Request)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CoprocessorStreamArgs_Req_DEFAULT *coprocessor.Request

func (p *CoprocessorStreamArgs) GetReq() *coprocessor.Request {
	if !p.IsSetReq() {
		return CoprocessorStreamArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CoprocessorStreamArgs) IsSetReq() bool {
	return p.Req != nil
}

type CoprocessorStreamResult struct {
	Success *coprocessor.Response
}

var CoprocessorStreamResult_Success_DEFAULT *coprocessor.Response

func (p *CoprocessorStreamResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CoprocessorStreamResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CoprocessorStreamResult) Unmarshal(in []byte) error {
	msg := new(coprocessor.Response)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CoprocessorStreamResult) GetSuccess() *coprocessor.Response {
	if !p.IsSetSuccess() {
		return CoprocessorStreamResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CoprocessorStreamResult) SetSuccess(x interface{}) {
	p.Success = x.(*coprocessor.Response)
}

func (p *CoprocessorStreamResult) IsSetSuccess() bool {
	return p.Success != nil
}

func batchCoprocessorHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &tikvBatchCoprocessorServer{st}
	req := new(coprocessor.BatchRequest)
	if err := st.RecvMsg(req); err != nil {
		return err
	}
	return handler.(tikvpb.Tikv).BatchCoprocessor(req, stream)
}

type tikvBatchCoprocessorClient struct {
	streaming.Stream
}

func (x *tikvBatchCoprocessorClient) Recv() (*coprocessor.BatchResponse, error) {
	m := new(coprocessor.BatchResponse)
	return m, x.Stream.RecvMsg(m)
}

type tikvBatchCoprocessorServer struct {
	streaming.Stream
}

func (x *tikvBatchCoprocessorServer) Send(m *coprocessor.BatchResponse) error {
	return x.Stream.SendMsg(m)
}

func newBatchCoprocessorArgs() interface{} {
	return &BatchCoprocessorArgs{}
}

func newBatchCoprocessorResult() interface{} {
	return &BatchCoprocessorResult{}
}

type BatchCoprocessorArgs struct {
	Req *coprocessor.BatchRequest
}

func (p *BatchCoprocessorArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in BatchCoprocessorArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *BatchCoprocessorArgs) Unmarshal(in []byte) error {
	msg := new(coprocessor.BatchRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var BatchCoprocessorArgs_Req_DEFAULT *coprocessor.BatchRequest

func (p *BatchCoprocessorArgs) GetReq() *coprocessor.BatchRequest {
	if !p.IsSetReq() {
		return BatchCoprocessorArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *BatchCoprocessorArgs) IsSetReq() bool {
	return p.Req != nil
}

type BatchCoprocessorResult struct {
	Success *coprocessor.BatchResponse
}

var BatchCoprocessorResult_Success_DEFAULT *coprocessor.BatchResponse

func (p *BatchCoprocessorResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in BatchCoprocessorResult")
	}
	return proto.Marshal(p.Success)
}

func (p *BatchCoprocessorResult) Unmarshal(in []byte) error {
	msg := new(coprocessor.BatchResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *BatchCoprocessorResult) GetSuccess() *coprocessor.BatchResponse {
	if !p.IsSetSuccess() {
		return BatchCoprocessorResult_Success_DEFAULT
	}
	return p.Success
}

func (p *BatchCoprocessorResult) SetSuccess(x interface{}) {
	p.Success = x.(*coprocessor.BatchResponse)
}

func (p *BatchCoprocessorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawCoprocessorHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.RawCoprocessorRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).RawCoprocessor(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RawCoprocessorArgs:
		success, err := handler.(tikvpb.Tikv).RawCoprocessor(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RawCoprocessorResult)
		realResult.Success = success
	}
	return nil
}
func newRawCoprocessorArgs() interface{} {
	return &RawCoprocessorArgs{}
}

func newRawCoprocessorResult() interface{} {
	return &RawCoprocessorResult{}
}

type RawCoprocessorArgs struct {
	Req *kvrpcpb.RawCoprocessorRequest
}

func (p *RawCoprocessorArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawCoprocessorArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawCoprocessorArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawCoprocessorRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawCoprocessorArgs_Req_DEFAULT *kvrpcpb.RawCoprocessorRequest

func (p *RawCoprocessorArgs) GetReq() *kvrpcpb.RawCoprocessorRequest {
	if !p.IsSetReq() {
		return RawCoprocessorArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawCoprocessorArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawCoprocessorResult struct {
	Success *kvrpcpb.RawCoprocessorResponse
}

var RawCoprocessorResult_Success_DEFAULT *kvrpcpb.RawCoprocessorResponse

func (p *RawCoprocessorResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawCoprocessorResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawCoprocessorResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.RawCoprocessorResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawCoprocessorResult) GetSuccess() *kvrpcpb.RawCoprocessorResponse {
	if !p.IsSetSuccess() {
		return RawCoprocessorResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawCoprocessorResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.RawCoprocessorResponse)
}

func (p *RawCoprocessorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func raftHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &tikvRaftServer{st}
	return handler.(tikvpb.Tikv).Raft(stream)
}

type tikvRaftClient struct {
	streaming.Stream
}

func (x *tikvRaftClient) Send(m *raft_serverpb.RaftMessage) error {
	return x.Stream.SendMsg(m)
}
func (x *tikvRaftClient) CloseAndRecv() (*raft_serverpb.Done, error) {
	if err := x.Stream.Close(); err != nil {
		return nil, err
	}
	m := new(raft_serverpb.Done)
	return m, x.Stream.RecvMsg(m)
}

type tikvRaftServer struct {
	streaming.Stream
}

func (x *tikvRaftServer) SendAndClose(m *raft_serverpb.Done) error {
	return x.Stream.SendMsg(m)
}

func (x *tikvRaftServer) Recv() (*raft_serverpb.RaftMessage, error) {
	m := new(raft_serverpb.RaftMessage)
	return m, x.Stream.RecvMsg(m)
}

func newRaftArgs() interface{} {
	return &RaftArgs{}
}

func newRaftResult() interface{} {
	return &RaftResult{}
}

type RaftArgs struct {
	Req *raft_serverpb.RaftMessage
}

func (p *RaftArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RaftArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RaftArgs) Unmarshal(in []byte) error {
	msg := new(raft_serverpb.RaftMessage)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RaftArgs_Req_DEFAULT *raft_serverpb.RaftMessage

func (p *RaftArgs) GetReq() *raft_serverpb.RaftMessage {
	if !p.IsSetReq() {
		return RaftArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RaftArgs) IsSetReq() bool {
	return p.Req != nil
}

type RaftResult struct {
	Success *raft_serverpb.Done
}

var RaftResult_Success_DEFAULT *raft_serverpb.Done

func (p *RaftResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RaftResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RaftResult) Unmarshal(in []byte) error {
	msg := new(raft_serverpb.Done)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RaftResult) GetSuccess() *raft_serverpb.Done {
	if !p.IsSetSuccess() {
		return RaftResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RaftResult) SetSuccess(x interface{}) {
	p.Success = x.(*raft_serverpb.Done)
}

func (p *RaftResult) IsSetSuccess() bool {
	return p.Success != nil
}

func batchRaftHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &tikvBatchRaftServer{st}
	return handler.(tikvpb.Tikv).BatchRaft(stream)
}

type tikvBatchRaftClient struct {
	streaming.Stream
}

func (x *tikvBatchRaftClient) Send(m *tikvpb.BatchRaftMessage) error {
	return x.Stream.SendMsg(m)
}
func (x *tikvBatchRaftClient) CloseAndRecv() (*raft_serverpb.Done, error) {
	if err := x.Stream.Close(); err != nil {
		return nil, err
	}
	m := new(raft_serverpb.Done)
	return m, x.Stream.RecvMsg(m)
}

type tikvBatchRaftServer struct {
	streaming.Stream
}

func (x *tikvBatchRaftServer) SendAndClose(m *raft_serverpb.Done) error {
	return x.Stream.SendMsg(m)
}

func (x *tikvBatchRaftServer) Recv() (*tikvpb.BatchRaftMessage, error) {
	m := new(tikvpb.BatchRaftMessage)
	return m, x.Stream.RecvMsg(m)
}

func newBatchRaftArgs() interface{} {
	return &BatchRaftArgs{}
}

func newBatchRaftResult() interface{} {
	return &BatchRaftResult{}
}

type BatchRaftArgs struct {
	Req *tikvpb.BatchRaftMessage
}

func (p *BatchRaftArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in BatchRaftArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *BatchRaftArgs) Unmarshal(in []byte) error {
	msg := new(tikvpb.BatchRaftMessage)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var BatchRaftArgs_Req_DEFAULT *tikvpb.BatchRaftMessage

func (p *BatchRaftArgs) GetReq() *tikvpb.BatchRaftMessage {
	if !p.IsSetReq() {
		return BatchRaftArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *BatchRaftArgs) IsSetReq() bool {
	return p.Req != nil
}

type BatchRaftResult struct {
	Success *raft_serverpb.Done
}

var BatchRaftResult_Success_DEFAULT *raft_serverpb.Done

func (p *BatchRaftResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in BatchRaftResult")
	}
	return proto.Marshal(p.Success)
}

func (p *BatchRaftResult) Unmarshal(in []byte) error {
	msg := new(raft_serverpb.Done)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *BatchRaftResult) GetSuccess() *raft_serverpb.Done {
	if !p.IsSetSuccess() {
		return BatchRaftResult_Success_DEFAULT
	}
	return p.Success
}

func (p *BatchRaftResult) SetSuccess(x interface{}) {
	p.Success = x.(*raft_serverpb.Done)
}

func (p *BatchRaftResult) IsSetSuccess() bool {
	return p.Success != nil
}

func snapshotHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &tikvSnapshotServer{st}
	return handler.(tikvpb.Tikv).Snapshot(stream)
}

type tikvSnapshotClient struct {
	streaming.Stream
}

func (x *tikvSnapshotClient) Send(m *raft_serverpb.SnapshotChunk) error {
	return x.Stream.SendMsg(m)
}
func (x *tikvSnapshotClient) CloseAndRecv() (*raft_serverpb.Done, error) {
	if err := x.Stream.Close(); err != nil {
		return nil, err
	}
	m := new(raft_serverpb.Done)
	return m, x.Stream.RecvMsg(m)
}

type tikvSnapshotServer struct {
	streaming.Stream
}

func (x *tikvSnapshotServer) SendAndClose(m *raft_serverpb.Done) error {
	return x.Stream.SendMsg(m)
}

func (x *tikvSnapshotServer) Recv() (*raft_serverpb.SnapshotChunk, error) {
	m := new(raft_serverpb.SnapshotChunk)
	return m, x.Stream.RecvMsg(m)
}

func newSnapshotArgs() interface{} {
	return &SnapshotArgs{}
}

func newSnapshotResult() interface{} {
	return &SnapshotResult{}
}

type SnapshotArgs struct {
	Req *raft_serverpb.SnapshotChunk
}

func (p *SnapshotArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SnapshotArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SnapshotArgs) Unmarshal(in []byte) error {
	msg := new(raft_serverpb.SnapshotChunk)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SnapshotArgs_Req_DEFAULT *raft_serverpb.SnapshotChunk

func (p *SnapshotArgs) GetReq() *raft_serverpb.SnapshotChunk {
	if !p.IsSetReq() {
		return SnapshotArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SnapshotArgs) IsSetReq() bool {
	return p.Req != nil
}

type SnapshotResult struct {
	Success *raft_serverpb.Done
}

var SnapshotResult_Success_DEFAULT *raft_serverpb.Done

func (p *SnapshotResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SnapshotResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SnapshotResult) Unmarshal(in []byte) error {
	msg := new(raft_serverpb.Done)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SnapshotResult) GetSuccess() *raft_serverpb.Done {
	if !p.IsSetSuccess() {
		return SnapshotResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SnapshotResult) SetSuccess(x interface{}) {
	p.Success = x.(*raft_serverpb.Done)
}

func (p *SnapshotResult) IsSetSuccess() bool {
	return p.Success != nil
}

func splitRegionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.SplitRegionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).SplitRegion(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SplitRegionArgs:
		success, err := handler.(tikvpb.Tikv).SplitRegion(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SplitRegionResult)
		realResult.Success = success
	}
	return nil
}
func newSplitRegionArgs() interface{} {
	return &SplitRegionArgs{}
}

func newSplitRegionResult() interface{} {
	return &SplitRegionResult{}
}

type SplitRegionArgs struct {
	Req *kvrpcpb.SplitRegionRequest
}

func (p *SplitRegionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SplitRegionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SplitRegionArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.SplitRegionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SplitRegionArgs_Req_DEFAULT *kvrpcpb.SplitRegionRequest

func (p *SplitRegionArgs) GetReq() *kvrpcpb.SplitRegionRequest {
	if !p.IsSetReq() {
		return SplitRegionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SplitRegionArgs) IsSetReq() bool {
	return p.Req != nil
}

type SplitRegionResult struct {
	Success *kvrpcpb.SplitRegionResponse
}

var SplitRegionResult_Success_DEFAULT *kvrpcpb.SplitRegionResponse

func (p *SplitRegionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SplitRegionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SplitRegionResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.SplitRegionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SplitRegionResult) GetSuccess() *kvrpcpb.SplitRegionResponse {
	if !p.IsSetSuccess() {
		return SplitRegionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SplitRegionResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.SplitRegionResponse)
}

func (p *SplitRegionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func readIndexHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.ReadIndexRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).ReadIndex(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ReadIndexArgs:
		success, err := handler.(tikvpb.Tikv).ReadIndex(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ReadIndexResult)
		realResult.Success = success
	}
	return nil
}
func newReadIndexArgs() interface{} {
	return &ReadIndexArgs{}
}

func newReadIndexResult() interface{} {
	return &ReadIndexResult{}
}

type ReadIndexArgs struct {
	Req *kvrpcpb.ReadIndexRequest
}

func (p *ReadIndexArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ReadIndexArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ReadIndexArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ReadIndexRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ReadIndexArgs_Req_DEFAULT *kvrpcpb.ReadIndexRequest

func (p *ReadIndexArgs) GetReq() *kvrpcpb.ReadIndexRequest {
	if !p.IsSetReq() {
		return ReadIndexArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ReadIndexArgs) IsSetReq() bool {
	return p.Req != nil
}

type ReadIndexResult struct {
	Success *kvrpcpb.ReadIndexResponse
}

var ReadIndexResult_Success_DEFAULT *kvrpcpb.ReadIndexResponse

func (p *ReadIndexResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ReadIndexResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ReadIndexResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.ReadIndexResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ReadIndexResult) GetSuccess() *kvrpcpb.ReadIndexResponse {
	if !p.IsSetSuccess() {
		return ReadIndexResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ReadIndexResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.ReadIndexResponse)
}

func (p *ReadIndexResult) IsSetSuccess() bool {
	return p.Success != nil
}

func mvccGetByKeyHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.MvccGetByKeyRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).MvccGetByKey(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MvccGetByKeyArgs:
		success, err := handler.(tikvpb.Tikv).MvccGetByKey(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MvccGetByKeyResult)
		realResult.Success = success
	}
	return nil
}
func newMvccGetByKeyArgs() interface{} {
	return &MvccGetByKeyArgs{}
}

func newMvccGetByKeyResult() interface{} {
	return &MvccGetByKeyResult{}
}

type MvccGetByKeyArgs struct {
	Req *kvrpcpb.MvccGetByKeyRequest
}

func (p *MvccGetByKeyArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in MvccGetByKeyArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *MvccGetByKeyArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.MvccGetByKeyRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MvccGetByKeyArgs_Req_DEFAULT *kvrpcpb.MvccGetByKeyRequest

func (p *MvccGetByKeyArgs) GetReq() *kvrpcpb.MvccGetByKeyRequest {
	if !p.IsSetReq() {
		return MvccGetByKeyArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MvccGetByKeyArgs) IsSetReq() bool {
	return p.Req != nil
}

type MvccGetByKeyResult struct {
	Success *kvrpcpb.MvccGetByKeyResponse
}

var MvccGetByKeyResult_Success_DEFAULT *kvrpcpb.MvccGetByKeyResponse

func (p *MvccGetByKeyResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in MvccGetByKeyResult")
	}
	return proto.Marshal(p.Success)
}

func (p *MvccGetByKeyResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.MvccGetByKeyResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MvccGetByKeyResult) GetSuccess() *kvrpcpb.MvccGetByKeyResponse {
	if !p.IsSetSuccess() {
		return MvccGetByKeyResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MvccGetByKeyResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.MvccGetByKeyResponse)
}

func (p *MvccGetByKeyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func mvccGetByStartTsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.MvccGetByStartTsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).MvccGetByStartTs(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MvccGetByStartTsArgs:
		success, err := handler.(tikvpb.Tikv).MvccGetByStartTs(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MvccGetByStartTsResult)
		realResult.Success = success
	}
	return nil
}
func newMvccGetByStartTsArgs() interface{} {
	return &MvccGetByStartTsArgs{}
}

func newMvccGetByStartTsResult() interface{} {
	return &MvccGetByStartTsResult{}
}

type MvccGetByStartTsArgs struct {
	Req *kvrpcpb.MvccGetByStartTsRequest
}

func (p *MvccGetByStartTsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in MvccGetByStartTsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *MvccGetByStartTsArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.MvccGetByStartTsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MvccGetByStartTsArgs_Req_DEFAULT *kvrpcpb.MvccGetByStartTsRequest

func (p *MvccGetByStartTsArgs) GetReq() *kvrpcpb.MvccGetByStartTsRequest {
	if !p.IsSetReq() {
		return MvccGetByStartTsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MvccGetByStartTsArgs) IsSetReq() bool {
	return p.Req != nil
}

type MvccGetByStartTsResult struct {
	Success *kvrpcpb.MvccGetByStartTsResponse
}

var MvccGetByStartTsResult_Success_DEFAULT *kvrpcpb.MvccGetByStartTsResponse

func (p *MvccGetByStartTsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in MvccGetByStartTsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *MvccGetByStartTsResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.MvccGetByStartTsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MvccGetByStartTsResult) GetSuccess() *kvrpcpb.MvccGetByStartTsResponse {
	if !p.IsSetSuccess() {
		return MvccGetByStartTsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MvccGetByStartTsResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.MvccGetByStartTsResponse)
}

func (p *MvccGetByStartTsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func batchCommandsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &tikvBatchCommandsServer{st}
	return handler.(tikvpb.Tikv).BatchCommands(stream)
}

type tikvBatchCommandsClient struct {
	streaming.Stream
}

func (x *tikvBatchCommandsClient) Send(m *tikvpb.BatchCommandsRequest) error {
	return x.Stream.SendMsg(m)
}
func (x *tikvBatchCommandsClient) Recv() (*tikvpb.BatchCommandsResponse, error) {
	m := new(tikvpb.BatchCommandsResponse)
	return m, x.Stream.RecvMsg(m)
}

type tikvBatchCommandsServer struct {
	streaming.Stream
}

func (x *tikvBatchCommandsServer) Send(m *tikvpb.BatchCommandsResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *tikvBatchCommandsServer) Recv() (*tikvpb.BatchCommandsRequest, error) {
	m := new(tikvpb.BatchCommandsRequest)
	return m, x.Stream.RecvMsg(m)
}

func newBatchCommandsArgs() interface{} {
	return &BatchCommandsArgs{}
}

func newBatchCommandsResult() interface{} {
	return &BatchCommandsResult{}
}

type BatchCommandsArgs struct {
	Req *tikvpb.BatchCommandsRequest
}

func (p *BatchCommandsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in BatchCommandsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *BatchCommandsArgs) Unmarshal(in []byte) error {
	msg := new(tikvpb.BatchCommandsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var BatchCommandsArgs_Req_DEFAULT *tikvpb.BatchCommandsRequest

func (p *BatchCommandsArgs) GetReq() *tikvpb.BatchCommandsRequest {
	if !p.IsSetReq() {
		return BatchCommandsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *BatchCommandsArgs) IsSetReq() bool {
	return p.Req != nil
}

type BatchCommandsResult struct {
	Success *tikvpb.BatchCommandsResponse
}

var BatchCommandsResult_Success_DEFAULT *tikvpb.BatchCommandsResponse

func (p *BatchCommandsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in BatchCommandsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *BatchCommandsResult) Unmarshal(in []byte) error {
	msg := new(tikvpb.BatchCommandsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *BatchCommandsResult) GetSuccess() *tikvpb.BatchCommandsResponse {
	if !p.IsSetSuccess() {
		return BatchCommandsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *BatchCommandsResult) SetSuccess(x interface{}) {
	p.Success = x.(*tikvpb.BatchCommandsResponse)
}

func (p *BatchCommandsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func dispatchMPPTaskHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(mpp.DispatchTaskRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).DispatchMPPTask(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DispatchMPPTaskArgs:
		success, err := handler.(tikvpb.Tikv).DispatchMPPTask(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DispatchMPPTaskResult)
		realResult.Success = success
	}
	return nil
}
func newDispatchMPPTaskArgs() interface{} {
	return &DispatchMPPTaskArgs{}
}

func newDispatchMPPTaskResult() interface{} {
	return &DispatchMPPTaskResult{}
}

type DispatchMPPTaskArgs struct {
	Req *mpp.DispatchTaskRequest
}

func (p *DispatchMPPTaskArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DispatchMPPTaskArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DispatchMPPTaskArgs) Unmarshal(in []byte) error {
	msg := new(mpp.DispatchTaskRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DispatchMPPTaskArgs_Req_DEFAULT *mpp.DispatchTaskRequest

func (p *DispatchMPPTaskArgs) GetReq() *mpp.DispatchTaskRequest {
	if !p.IsSetReq() {
		return DispatchMPPTaskArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DispatchMPPTaskArgs) IsSetReq() bool {
	return p.Req != nil
}

type DispatchMPPTaskResult struct {
	Success *mpp.DispatchTaskResponse
}

var DispatchMPPTaskResult_Success_DEFAULT *mpp.DispatchTaskResponse

func (p *DispatchMPPTaskResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DispatchMPPTaskResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DispatchMPPTaskResult) Unmarshal(in []byte) error {
	msg := new(mpp.DispatchTaskResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DispatchMPPTaskResult) GetSuccess() *mpp.DispatchTaskResponse {
	if !p.IsSetSuccess() {
		return DispatchMPPTaskResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DispatchMPPTaskResult) SetSuccess(x interface{}) {
	p.Success = x.(*mpp.DispatchTaskResponse)
}

func (p *DispatchMPPTaskResult) IsSetSuccess() bool {
	return p.Success != nil
}

func cancelMPPTaskHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(mpp.CancelTaskRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).CancelMPPTask(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CancelMPPTaskArgs:
		success, err := handler.(tikvpb.Tikv).CancelMPPTask(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CancelMPPTaskResult)
		realResult.Success = success
	}
	return nil
}
func newCancelMPPTaskArgs() interface{} {
	return &CancelMPPTaskArgs{}
}

func newCancelMPPTaskResult() interface{} {
	return &CancelMPPTaskResult{}
}

type CancelMPPTaskArgs struct {
	Req *mpp.CancelTaskRequest
}

func (p *CancelMPPTaskArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CancelMPPTaskArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CancelMPPTaskArgs) Unmarshal(in []byte) error {
	msg := new(mpp.CancelTaskRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CancelMPPTaskArgs_Req_DEFAULT *mpp.CancelTaskRequest

func (p *CancelMPPTaskArgs) GetReq() *mpp.CancelTaskRequest {
	if !p.IsSetReq() {
		return CancelMPPTaskArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CancelMPPTaskArgs) IsSetReq() bool {
	return p.Req != nil
}

type CancelMPPTaskResult struct {
	Success *mpp.CancelTaskResponse
}

var CancelMPPTaskResult_Success_DEFAULT *mpp.CancelTaskResponse

func (p *CancelMPPTaskResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CancelMPPTaskResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CancelMPPTaskResult) Unmarshal(in []byte) error {
	msg := new(mpp.CancelTaskResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CancelMPPTaskResult) GetSuccess() *mpp.CancelTaskResponse {
	if !p.IsSetSuccess() {
		return CancelMPPTaskResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CancelMPPTaskResult) SetSuccess(x interface{}) {
	p.Success = x.(*mpp.CancelTaskResponse)
}

func (p *CancelMPPTaskResult) IsSetSuccess() bool {
	return p.Success != nil
}

func establishMPPConnectionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &tikvEstablishMPPConnectionServer{st}
	req := new(mpp.EstablishMPPConnectionRequest)
	if err := st.RecvMsg(req); err != nil {
		return err
	}
	return handler.(tikvpb.Tikv).EstablishMPPConnection(req, stream)
}

type tikvEstablishMPPConnectionClient struct {
	streaming.Stream
}

func (x *tikvEstablishMPPConnectionClient) Recv() (*mpp.MPPDataPacket, error) {
	m := new(mpp.MPPDataPacket)
	return m, x.Stream.RecvMsg(m)
}

type tikvEstablishMPPConnectionServer struct {
	streaming.Stream
}

func (x *tikvEstablishMPPConnectionServer) Send(m *mpp.MPPDataPacket) error {
	return x.Stream.SendMsg(m)
}

func newEstablishMPPConnectionArgs() interface{} {
	return &EstablishMPPConnectionArgs{}
}

func newEstablishMPPConnectionResult() interface{} {
	return &EstablishMPPConnectionResult{}
}

type EstablishMPPConnectionArgs struct {
	Req *mpp.EstablishMPPConnectionRequest
}

func (p *EstablishMPPConnectionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in EstablishMPPConnectionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *EstablishMPPConnectionArgs) Unmarshal(in []byte) error {
	msg := new(mpp.EstablishMPPConnectionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var EstablishMPPConnectionArgs_Req_DEFAULT *mpp.EstablishMPPConnectionRequest

func (p *EstablishMPPConnectionArgs) GetReq() *mpp.EstablishMPPConnectionRequest {
	if !p.IsSetReq() {
		return EstablishMPPConnectionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *EstablishMPPConnectionArgs) IsSetReq() bool {
	return p.Req != nil
}

type EstablishMPPConnectionResult struct {
	Success *mpp.MPPDataPacket
}

var EstablishMPPConnectionResult_Success_DEFAULT *mpp.MPPDataPacket

func (p *EstablishMPPConnectionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in EstablishMPPConnectionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *EstablishMPPConnectionResult) Unmarshal(in []byte) error {
	msg := new(mpp.MPPDataPacket)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *EstablishMPPConnectionResult) GetSuccess() *mpp.MPPDataPacket {
	if !p.IsSetSuccess() {
		return EstablishMPPConnectionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *EstablishMPPConnectionResult) SetSuccess(x interface{}) {
	p.Success = x.(*mpp.MPPDataPacket)
}

func (p *EstablishMPPConnectionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func isAliveHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(mpp.IsAliveRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).IsAlive(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *IsAliveArgs:
		success, err := handler.(tikvpb.Tikv).IsAlive(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*IsAliveResult)
		realResult.Success = success
	}
	return nil
}
func newIsAliveArgs() interface{} {
	return &IsAliveArgs{}
}

func newIsAliveResult() interface{} {
	return &IsAliveResult{}
}

type IsAliveArgs struct {
	Req *mpp.IsAliveRequest
}

func (p *IsAliveArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in IsAliveArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *IsAliveArgs) Unmarshal(in []byte) error {
	msg := new(mpp.IsAliveRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var IsAliveArgs_Req_DEFAULT *mpp.IsAliveRequest

func (p *IsAliveArgs) GetReq() *mpp.IsAliveRequest {
	if !p.IsSetReq() {
		return IsAliveArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *IsAliveArgs) IsSetReq() bool {
	return p.Req != nil
}

type IsAliveResult struct {
	Success *mpp.IsAliveResponse
}

var IsAliveResult_Success_DEFAULT *mpp.IsAliveResponse

func (p *IsAliveResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in IsAliveResult")
	}
	return proto.Marshal(p.Success)
}

func (p *IsAliveResult) Unmarshal(in []byte) error {
	msg := new(mpp.IsAliveResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *IsAliveResult) GetSuccess() *mpp.IsAliveResponse {
	if !p.IsSetSuccess() {
		return IsAliveResult_Success_DEFAULT
	}
	return p.Success
}

func (p *IsAliveResult) SetSuccess(x interface{}) {
	p.Success = x.(*mpp.IsAliveResponse)
}

func (p *IsAliveResult) IsSetSuccess() bool {
	return p.Success != nil
}

func checkLeaderHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.CheckLeaderRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).CheckLeader(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CheckLeaderArgs:
		success, err := handler.(tikvpb.Tikv).CheckLeader(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CheckLeaderResult)
		realResult.Success = success
	}
	return nil
}
func newCheckLeaderArgs() interface{} {
	return &CheckLeaderArgs{}
}

func newCheckLeaderResult() interface{} {
	return &CheckLeaderResult{}
}

type CheckLeaderArgs struct {
	Req *kvrpcpb.CheckLeaderRequest
}

func (p *CheckLeaderArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CheckLeaderArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CheckLeaderArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CheckLeaderRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CheckLeaderArgs_Req_DEFAULT *kvrpcpb.CheckLeaderRequest

func (p *CheckLeaderArgs) GetReq() *kvrpcpb.CheckLeaderRequest {
	if !p.IsSetReq() {
		return CheckLeaderArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CheckLeaderArgs) IsSetReq() bool {
	return p.Req != nil
}

type CheckLeaderResult struct {
	Success *kvrpcpb.CheckLeaderResponse
}

var CheckLeaderResult_Success_DEFAULT *kvrpcpb.CheckLeaderResponse

func (p *CheckLeaderResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CheckLeaderResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CheckLeaderResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.CheckLeaderResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CheckLeaderResult) GetSuccess() *kvrpcpb.CheckLeaderResponse {
	if !p.IsSetSuccess() {
		return CheckLeaderResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CheckLeaderResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.CheckLeaderResponse)
}

func (p *CheckLeaderResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getStoreSafeTSHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.StoreSafeTSRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).GetStoreSafeTS(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetStoreSafeTSArgs:
		success, err := handler.(tikvpb.Tikv).GetStoreSafeTS(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetStoreSafeTSResult)
		realResult.Success = success
	}
	return nil
}
func newGetStoreSafeTSArgs() interface{} {
	return &GetStoreSafeTSArgs{}
}

func newGetStoreSafeTSResult() interface{} {
	return &GetStoreSafeTSResult{}
}

type GetStoreSafeTSArgs struct {
	Req *kvrpcpb.StoreSafeTSRequest
}

func (p *GetStoreSafeTSArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetStoreSafeTSArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetStoreSafeTSArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.StoreSafeTSRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetStoreSafeTSArgs_Req_DEFAULT *kvrpcpb.StoreSafeTSRequest

func (p *GetStoreSafeTSArgs) GetReq() *kvrpcpb.StoreSafeTSRequest {
	if !p.IsSetReq() {
		return GetStoreSafeTSArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetStoreSafeTSArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetStoreSafeTSResult struct {
	Success *kvrpcpb.StoreSafeTSResponse
}

var GetStoreSafeTSResult_Success_DEFAULT *kvrpcpb.StoreSafeTSResponse

func (p *GetStoreSafeTSResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetStoreSafeTSResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetStoreSafeTSResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.StoreSafeTSResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetStoreSafeTSResult) GetSuccess() *kvrpcpb.StoreSafeTSResponse {
	if !p.IsSetSuccess() {
		return GetStoreSafeTSResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetStoreSafeTSResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.StoreSafeTSResponse)
}

func (p *GetStoreSafeTSResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getLockWaitInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(kvrpcpb.GetLockWaitInfoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(tikvpb.Tikv).GetLockWaitInfo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetLockWaitInfoArgs:
		success, err := handler.(tikvpb.Tikv).GetLockWaitInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetLockWaitInfoResult)
		realResult.Success = success
	}
	return nil
}
func newGetLockWaitInfoArgs() interface{} {
	return &GetLockWaitInfoArgs{}
}

func newGetLockWaitInfoResult() interface{} {
	return &GetLockWaitInfoResult{}
}

type GetLockWaitInfoArgs struct {
	Req *kvrpcpb.GetLockWaitInfoRequest
}

func (p *GetLockWaitInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetLockWaitInfoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetLockWaitInfoArgs) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.GetLockWaitInfoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetLockWaitInfoArgs_Req_DEFAULT *kvrpcpb.GetLockWaitInfoRequest

func (p *GetLockWaitInfoArgs) GetReq() *kvrpcpb.GetLockWaitInfoRequest {
	if !p.IsSetReq() {
		return GetLockWaitInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetLockWaitInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetLockWaitInfoResult struct {
	Success *kvrpcpb.GetLockWaitInfoResponse
}

var GetLockWaitInfoResult_Success_DEFAULT *kvrpcpb.GetLockWaitInfoResponse

func (p *GetLockWaitInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetLockWaitInfoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetLockWaitInfoResult) Unmarshal(in []byte) error {
	msg := new(kvrpcpb.GetLockWaitInfoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetLockWaitInfoResult) GetSuccess() *kvrpcpb.GetLockWaitInfoResponse {
	if !p.IsSetSuccess() {
		return GetLockWaitInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetLockWaitInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*kvrpcpb.GetLockWaitInfoResponse)
}

func (p *GetLockWaitInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) KvGet(ctx context.Context, Req *kvrpcpb.GetRequest) (r *kvrpcpb.GetResponse, err error) {
	var _args KvGetArgs
	_args.Req = Req
	var _result KvGetResult
	if err = p.c.Call(ctx, "KvGet", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvScan(ctx context.Context, Req *kvrpcpb.ScanRequest) (r *kvrpcpb.ScanResponse, err error) {
	var _args KvScanArgs
	_args.Req = Req
	var _result KvScanResult
	if err = p.c.Call(ctx, "KvScan", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvPrewrite(ctx context.Context, Req *kvrpcpb.PrewriteRequest) (r *kvrpcpb.PrewriteResponse, err error) {
	var _args KvPrewriteArgs
	_args.Req = Req
	var _result KvPrewriteResult
	if err = p.c.Call(ctx, "KvPrewrite", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvPessimisticLock(ctx context.Context, Req *kvrpcpb.PessimisticLockRequest) (r *kvrpcpb.PessimisticLockResponse, err error) {
	var _args KvPessimisticLockArgs
	_args.Req = Req
	var _result KvPessimisticLockResult
	if err = p.c.Call(ctx, "KvPessimisticLock", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KVPessimisticRollback(ctx context.Context, Req *kvrpcpb.PessimisticRollbackRequest) (r *kvrpcpb.PessimisticRollbackResponse, err error) {
	var _args KVPessimisticRollbackArgs
	_args.Req = Req
	var _result KVPessimisticRollbackResult
	if err = p.c.Call(ctx, "KVPessimisticRollback", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvTxnHeartBeat(ctx context.Context, Req *kvrpcpb.TxnHeartBeatRequest) (r *kvrpcpb.TxnHeartBeatResponse, err error) {
	var _args KvTxnHeartBeatArgs
	_args.Req = Req
	var _result KvTxnHeartBeatResult
	if err = p.c.Call(ctx, "KvTxnHeartBeat", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvCheckTxnStatus(ctx context.Context, Req *kvrpcpb.CheckTxnStatusRequest) (r *kvrpcpb.CheckTxnStatusResponse, err error) {
	var _args KvCheckTxnStatusArgs
	_args.Req = Req
	var _result KvCheckTxnStatusResult
	if err = p.c.Call(ctx, "KvCheckTxnStatus", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvCheckSecondaryLocks(ctx context.Context, Req *kvrpcpb.CheckSecondaryLocksRequest) (r *kvrpcpb.CheckSecondaryLocksResponse, err error) {
	var _args KvCheckSecondaryLocksArgs
	_args.Req = Req
	var _result KvCheckSecondaryLocksResult
	if err = p.c.Call(ctx, "KvCheckSecondaryLocks", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvCommit(ctx context.Context, Req *kvrpcpb.CommitRequest) (r *kvrpcpb.CommitResponse, err error) {
	var _args KvCommitArgs
	_args.Req = Req
	var _result KvCommitResult
	if err = p.c.Call(ctx, "KvCommit", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvImport(ctx context.Context, Req *kvrpcpb.ImportRequest) (r *kvrpcpb.ImportResponse, err error) {
	var _args KvImportArgs
	_args.Req = Req
	var _result KvImportResult
	if err = p.c.Call(ctx, "KvImport", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvCleanup(ctx context.Context, Req *kvrpcpb.CleanupRequest) (r *kvrpcpb.CleanupResponse, err error) {
	var _args KvCleanupArgs
	_args.Req = Req
	var _result KvCleanupResult
	if err = p.c.Call(ctx, "KvCleanup", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvBatchGet(ctx context.Context, Req *kvrpcpb.BatchGetRequest) (r *kvrpcpb.BatchGetResponse, err error) {
	var _args KvBatchGetArgs
	_args.Req = Req
	var _result KvBatchGetResult
	if err = p.c.Call(ctx, "KvBatchGet", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvBatchRollback(ctx context.Context, Req *kvrpcpb.BatchRollbackRequest) (r *kvrpcpb.BatchRollbackResponse, err error) {
	var _args KvBatchRollbackArgs
	_args.Req = Req
	var _result KvBatchRollbackResult
	if err = p.c.Call(ctx, "KvBatchRollback", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvScanLock(ctx context.Context, Req *kvrpcpb.ScanLockRequest) (r *kvrpcpb.ScanLockResponse, err error) {
	var _args KvScanLockArgs
	_args.Req = Req
	var _result KvScanLockResult
	if err = p.c.Call(ctx, "KvScanLock", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvResolveLock(ctx context.Context, Req *kvrpcpb.ResolveLockRequest) (r *kvrpcpb.ResolveLockResponse, err error) {
	var _args KvResolveLockArgs
	_args.Req = Req
	var _result KvResolveLockResult
	if err = p.c.Call(ctx, "KvResolveLock", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvGC(ctx context.Context, Req *kvrpcpb.GCRequest) (r *kvrpcpb.GCResponse, err error) {
	var _args KvGCArgs
	_args.Req = Req
	var _result KvGCResult
	if err = p.c.Call(ctx, "KvGC", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) KvDeleteRange(ctx context.Context, Req *kvrpcpb.DeleteRangeRequest) (r *kvrpcpb.DeleteRangeResponse, err error) {
	var _args KvDeleteRangeArgs
	_args.Req = Req
	var _result KvDeleteRangeResult
	if err = p.c.Call(ctx, "KvDeleteRange", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawGet(ctx context.Context, Req *kvrpcpb.RawGetRequest) (r *kvrpcpb.RawGetResponse, err error) {
	var _args RawGetArgs
	_args.Req = Req
	var _result RawGetResult
	if err = p.c.Call(ctx, "RawGet", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawBatchGet(ctx context.Context, Req *kvrpcpb.RawBatchGetRequest) (r *kvrpcpb.RawBatchGetResponse, err error) {
	var _args RawBatchGetArgs
	_args.Req = Req
	var _result RawBatchGetResult
	if err = p.c.Call(ctx, "RawBatchGet", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawPut(ctx context.Context, Req *kvrpcpb.RawPutRequest) (r *kvrpcpb.RawPutResponse, err error) {
	var _args RawPutArgs
	_args.Req = Req
	var _result RawPutResult
	if err = p.c.Call(ctx, "RawPut", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawBatchPut(ctx context.Context, Req *kvrpcpb.RawBatchPutRequest) (r *kvrpcpb.RawBatchPutResponse, err error) {
	var _args RawBatchPutArgs
	_args.Req = Req
	var _result RawBatchPutResult
	if err = p.c.Call(ctx, "RawBatchPut", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawDelete(ctx context.Context, Req *kvrpcpb.RawDeleteRequest) (r *kvrpcpb.RawDeleteResponse, err error) {
	var _args RawDeleteArgs
	_args.Req = Req
	var _result RawDeleteResult
	if err = p.c.Call(ctx, "RawDelete", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawBatchDelete(ctx context.Context, Req *kvrpcpb.RawBatchDeleteRequest) (r *kvrpcpb.RawBatchDeleteResponse, err error) {
	var _args RawBatchDeleteArgs
	_args.Req = Req
	var _result RawBatchDeleteResult
	if err = p.c.Call(ctx, "RawBatchDelete", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawScan(ctx context.Context, Req *kvrpcpb.RawScanRequest) (r *kvrpcpb.RawScanResponse, err error) {
	var _args RawScanArgs
	_args.Req = Req
	var _result RawScanResult
	if err = p.c.Call(ctx, "RawScan", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawDeleteRange(ctx context.Context, Req *kvrpcpb.RawDeleteRangeRequest) (r *kvrpcpb.RawDeleteRangeResponse, err error) {
	var _args RawDeleteRangeArgs
	_args.Req = Req
	var _result RawDeleteRangeResult
	if err = p.c.Call(ctx, "RawDeleteRange", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawBatchScan(ctx context.Context, Req *kvrpcpb.RawBatchScanRequest) (r *kvrpcpb.RawBatchScanResponse, err error) {
	var _args RawBatchScanArgs
	_args.Req = Req
	var _result RawBatchScanResult
	if err = p.c.Call(ctx, "RawBatchScan", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawGetKeyTTL(ctx context.Context, Req *kvrpcpb.RawGetKeyTTLRequest) (r *kvrpcpb.RawGetKeyTTLResponse, err error) {
	var _args RawGetKeyTTLArgs
	_args.Req = Req
	var _result RawGetKeyTTLResult
	if err = p.c.Call(ctx, "RawGetKeyTTL", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawCompareAndSwap(ctx context.Context, Req *kvrpcpb.RawCASRequest) (r *kvrpcpb.RawCASResponse, err error) {
	var _args RawCompareAndSwapArgs
	_args.Req = Req
	var _result RawCompareAndSwapResult
	if err = p.c.Call(ctx, "RawCompareAndSwap", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RawChecksum(ctx context.Context, Req *kvrpcpb.RawChecksumRequest) (r *kvrpcpb.RawChecksumResponse, err error) {
	var _args RawChecksumArgs
	_args.Req = Req
	var _result RawChecksumResult
	if err = p.c.Call(ctx, "RawChecksum", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UnsafeDestroyRange(ctx context.Context, Req *kvrpcpb.UnsafeDestroyRangeRequest) (r *kvrpcpb.UnsafeDestroyRangeResponse, err error) {
	var _args UnsafeDestroyRangeArgs
	_args.Req = Req
	var _result UnsafeDestroyRangeResult
	if err = p.c.Call(ctx, "UnsafeDestroyRange", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RegisterLockObserver(ctx context.Context, Req *kvrpcpb.RegisterLockObserverRequest) (r *kvrpcpb.RegisterLockObserverResponse, err error) {
	var _args RegisterLockObserverArgs
	_args.Req = Req
	var _result RegisterLockObserverResult
	if err = p.c.Call(ctx, "RegisterLockObserver", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CheckLockObserver(ctx context.Context, Req *kvrpcpb.CheckLockObserverRequest) (r *kvrpcpb.CheckLockObserverResponse, err error) {
	var _args CheckLockObserverArgs
	_args.Req = Req
	var _result CheckLockObserverResult
	if err = p.c.Call(ctx, "CheckLockObserver", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RemoveLockObserver(ctx context.Context, Req *kvrpcpb.RemoveLockObserverRequest) (r *kvrpcpb.RemoveLockObserverResponse, err error) {
	var _args RemoveLockObserverArgs
	_args.Req = Req
	var _result RemoveLockObserverResult
	if err = p.c.Call(ctx, "RemoveLockObserver", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PhysicalScanLock(ctx context.Context, Req *kvrpcpb.PhysicalScanLockRequest) (r *kvrpcpb.PhysicalScanLockResponse, err error) {
	var _args PhysicalScanLockArgs
	_args.Req = Req
	var _result PhysicalScanLockResult
	if err = p.c.Call(ctx, "PhysicalScanLock", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Coprocessor(ctx context.Context, Req *coprocessor.Request) (r *coprocessor.Response, err error) {
	var _args CoprocessorArgs
	_args.Req = Req
	var _result CoprocessorResult
	if err = p.c.Call(ctx, "Coprocessor", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CoprocessorStream(ctx context.Context, req *coprocessor.Request) (Tikv_CoprocessorStreamClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "CoprocessorStream", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &tikvCoprocessorStreamClient{res.Stream}
	if err := stream.Stream.SendMsg(req); err != nil {
		return nil, err
	}
	if err := stream.Stream.Close(); err != nil {
		return nil, err
	}
	return stream, nil
}

func (p *kClient) BatchCoprocessor(ctx context.Context, req *coprocessor.BatchRequest) (Tikv_BatchCoprocessorClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "BatchCoprocessor", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &tikvBatchCoprocessorClient{res.Stream}
	if err := stream.Stream.SendMsg(req); err != nil {
		return nil, err
	}
	if err := stream.Stream.Close(); err != nil {
		return nil, err
	}
	return stream, nil
}

func (p *kClient) RawCoprocessor(ctx context.Context, Req *kvrpcpb.RawCoprocessorRequest) (r *kvrpcpb.RawCoprocessorResponse, err error) {
	var _args RawCoprocessorArgs
	_args.Req = Req
	var _result RawCoprocessorResult
	if err = p.c.Call(ctx, "RawCoprocessor", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Raft(ctx context.Context) (Tikv_RaftClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "Raft", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &tikvRaftClient{res.Stream}
	return stream, nil
}

func (p *kClient) BatchRaft(ctx context.Context) (Tikv_BatchRaftClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "BatchRaft", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &tikvBatchRaftClient{res.Stream}
	return stream, nil
}

func (p *kClient) Snapshot(ctx context.Context) (Tikv_SnapshotClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "Snapshot", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &tikvSnapshotClient{res.Stream}
	return stream, nil
}

func (p *kClient) SplitRegion(ctx context.Context, Req *kvrpcpb.SplitRegionRequest) (r *kvrpcpb.SplitRegionResponse, err error) {
	var _args SplitRegionArgs
	_args.Req = Req
	var _result SplitRegionResult
	if err = p.c.Call(ctx, "SplitRegion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ReadIndex(ctx context.Context, Req *kvrpcpb.ReadIndexRequest) (r *kvrpcpb.ReadIndexResponse, err error) {
	var _args ReadIndexArgs
	_args.Req = Req
	var _result ReadIndexResult
	if err = p.c.Call(ctx, "ReadIndex", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MvccGetByKey(ctx context.Context, Req *kvrpcpb.MvccGetByKeyRequest) (r *kvrpcpb.MvccGetByKeyResponse, err error) {
	var _args MvccGetByKeyArgs
	_args.Req = Req
	var _result MvccGetByKeyResult
	if err = p.c.Call(ctx, "MvccGetByKey", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MvccGetByStartTs(ctx context.Context, Req *kvrpcpb.MvccGetByStartTsRequest) (r *kvrpcpb.MvccGetByStartTsResponse, err error) {
	var _args MvccGetByStartTsArgs
	_args.Req = Req
	var _result MvccGetByStartTsResult
	if err = p.c.Call(ctx, "MvccGetByStartTs", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) BatchCommands(ctx context.Context) (Tikv_BatchCommandsClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "BatchCommands", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &tikvBatchCommandsClient{res.Stream}
	return stream, nil
}

func (p *kClient) DispatchMPPTask(ctx context.Context, Req *mpp.DispatchTaskRequest) (r *mpp.DispatchTaskResponse, err error) {
	var _args DispatchMPPTaskArgs
	_args.Req = Req
	var _result DispatchMPPTaskResult
	if err = p.c.Call(ctx, "DispatchMPPTask", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CancelMPPTask(ctx context.Context, Req *mpp.CancelTaskRequest) (r *mpp.CancelTaskResponse, err error) {
	var _args CancelMPPTaskArgs
	_args.Req = Req
	var _result CancelMPPTaskResult
	if err = p.c.Call(ctx, "CancelMPPTask", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) EstablishMPPConnection(ctx context.Context, req *mpp.EstablishMPPConnectionRequest) (Tikv_EstablishMPPConnectionClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "EstablishMPPConnection", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &tikvEstablishMPPConnectionClient{res.Stream}
	if err := stream.Stream.SendMsg(req); err != nil {
		return nil, err
	}
	if err := stream.Stream.Close(); err != nil {
		return nil, err
	}
	return stream, nil
}

func (p *kClient) IsAlive(ctx context.Context, Req *mpp.IsAliveRequest) (r *mpp.IsAliveResponse, err error) {
	var _args IsAliveArgs
	_args.Req = Req
	var _result IsAliveResult
	if err = p.c.Call(ctx, "IsAlive", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CheckLeader(ctx context.Context, Req *kvrpcpb.CheckLeaderRequest) (r *kvrpcpb.CheckLeaderResponse, err error) {
	var _args CheckLeaderArgs
	_args.Req = Req
	var _result CheckLeaderResult
	if err = p.c.Call(ctx, "CheckLeader", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetStoreSafeTS(ctx context.Context, Req *kvrpcpb.StoreSafeTSRequest) (r *kvrpcpb.StoreSafeTSResponse, err error) {
	var _args GetStoreSafeTSArgs
	_args.Req = Req
	var _result GetStoreSafeTSResult
	if err = p.c.Call(ctx, "GetStoreSafeTS", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetLockWaitInfo(ctx context.Context, Req *kvrpcpb.GetLockWaitInfoRequest) (r *kvrpcpb.GetLockWaitInfoResponse, err error) {
	var _args GetLockWaitInfoArgs
	_args.Req = Req
	var _result GetLockWaitInfoResult
	if err = p.c.Call(ctx, "GetLockWaitInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
