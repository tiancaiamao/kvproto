// Code generated by Kitex v0.1.3. DO NOT EDIT.

package debug

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/pingcap/kvproto/proto/kitex_gen/debugpb"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return debugServiceInfo
}

var debugServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "Debug"
	handlerType := (*debugpb.Debug)(nil)
	methods := map[string]kitex.MethodInfo{
		"Get":                    kitex.NewMethodInfo(getHandler, newGetArgs, newGetResult, false),
		"RaftLog":                kitex.NewMethodInfo(raftLogHandler, newRaftLogArgs, newRaftLogResult, false),
		"RegionInfo":             kitex.NewMethodInfo(regionInfoHandler, newRegionInfoArgs, newRegionInfoResult, false),
		"RegionSize":             kitex.NewMethodInfo(regionSizeHandler, newRegionSizeArgs, newRegionSizeResult, false),
		"ScanMvcc":               kitex.NewMethodInfo(scanMvccHandler, newScanMvccArgs, newScanMvccResult, false),
		"Compact":                kitex.NewMethodInfo(compactHandler, newCompactArgs, newCompactResult, false),
		"InjectFailPoint":        kitex.NewMethodInfo(injectFailPointHandler, newInjectFailPointArgs, newInjectFailPointResult, false),
		"RecoverFailPoint":       kitex.NewMethodInfo(recoverFailPointHandler, newRecoverFailPointArgs, newRecoverFailPointResult, false),
		"ListFailPoints":         kitex.NewMethodInfo(listFailPointsHandler, newListFailPointsArgs, newListFailPointsResult, false),
		"GetMetrics":             kitex.NewMethodInfo(getMetricsHandler, newGetMetricsArgs, newGetMetricsResult, false),
		"CheckRegionConsistency": kitex.NewMethodInfo(checkRegionConsistencyHandler, newCheckRegionConsistencyArgs, newCheckRegionConsistencyResult, false),
		"ModifyTikvConfig":       kitex.NewMethodInfo(modifyTikvConfigHandler, newModifyTikvConfigArgs, newModifyTikvConfigResult, false),
		"GetRegionProperties":    kitex.NewMethodInfo(getRegionPropertiesHandler, newGetRegionPropertiesArgs, newGetRegionPropertiesResult, false),
		"GetStoreInfo":           kitex.NewMethodInfo(getStoreInfoHandler, newGetStoreInfoArgs, newGetStoreInfoResult, false),
		"GetClusterInfo":         kitex.NewMethodInfo(getClusterInfoHandler, newGetClusterInfoArgs, newGetClusterInfoResult, false),
		"GetAllRegionsInStore":   kitex.NewMethodInfo(getAllRegionsInStoreHandler, newGetAllRegionsInStoreArgs, newGetAllRegionsInStoreResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "debugpb",
	}
	extra["streaming"] = true
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.1.3",
		Extra:           extra,
	}
	return svcInfo
}

func getHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.GetRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).Get(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetArgs:
		success, err := handler.(debugpb.Debug).Get(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetResult)
		realResult.Success = success
	}
	return nil
}
func newGetArgs() interface{} {
	return &GetArgs{}
}

func newGetResult() interface{} {
	return &GetResult{}
}

type GetArgs struct {
	Req *debugpb.GetRequest
}

func (p *GetArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.GetRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetArgs_Req_DEFAULT *debugpb.GetRequest

func (p *GetArgs) GetReq() *debugpb.GetRequest {
	if !p.IsSetReq() {
		return GetArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetResult struct {
	Success *debugpb.GetResponse
}

var GetResult_Success_DEFAULT *debugpb.GetResponse

func (p *GetResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetResult) Unmarshal(in []byte) error {
	msg := new(debugpb.GetResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetResult) GetSuccess() *debugpb.GetResponse {
	if !p.IsSetSuccess() {
		return GetResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.GetResponse)
}

func (p *GetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func raftLogHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.RaftLogRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).RaftLog(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RaftLogArgs:
		success, err := handler.(debugpb.Debug).RaftLog(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RaftLogResult)
		realResult.Success = success
	}
	return nil
}
func newRaftLogArgs() interface{} {
	return &RaftLogArgs{}
}

func newRaftLogResult() interface{} {
	return &RaftLogResult{}
}

type RaftLogArgs struct {
	Req *debugpb.RaftLogRequest
}

func (p *RaftLogArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RaftLogArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RaftLogArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.RaftLogRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RaftLogArgs_Req_DEFAULT *debugpb.RaftLogRequest

func (p *RaftLogArgs) GetReq() *debugpb.RaftLogRequest {
	if !p.IsSetReq() {
		return RaftLogArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RaftLogArgs) IsSetReq() bool {
	return p.Req != nil
}

type RaftLogResult struct {
	Success *debugpb.RaftLogResponse
}

var RaftLogResult_Success_DEFAULT *debugpb.RaftLogResponse

func (p *RaftLogResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RaftLogResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RaftLogResult) Unmarshal(in []byte) error {
	msg := new(debugpb.RaftLogResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RaftLogResult) GetSuccess() *debugpb.RaftLogResponse {
	if !p.IsSetSuccess() {
		return RaftLogResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RaftLogResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.RaftLogResponse)
}

func (p *RaftLogResult) IsSetSuccess() bool {
	return p.Success != nil
}

func regionInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.RegionInfoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).RegionInfo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RegionInfoArgs:
		success, err := handler.(debugpb.Debug).RegionInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RegionInfoResult)
		realResult.Success = success
	}
	return nil
}
func newRegionInfoArgs() interface{} {
	return &RegionInfoArgs{}
}

func newRegionInfoResult() interface{} {
	return &RegionInfoResult{}
}

type RegionInfoArgs struct {
	Req *debugpb.RegionInfoRequest
}

func (p *RegionInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RegionInfoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RegionInfoArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.RegionInfoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RegionInfoArgs_Req_DEFAULT *debugpb.RegionInfoRequest

func (p *RegionInfoArgs) GetReq() *debugpb.RegionInfoRequest {
	if !p.IsSetReq() {
		return RegionInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RegionInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

type RegionInfoResult struct {
	Success *debugpb.RegionInfoResponse
}

var RegionInfoResult_Success_DEFAULT *debugpb.RegionInfoResponse

func (p *RegionInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RegionInfoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RegionInfoResult) Unmarshal(in []byte) error {
	msg := new(debugpb.RegionInfoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RegionInfoResult) GetSuccess() *debugpb.RegionInfoResponse {
	if !p.IsSetSuccess() {
		return RegionInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RegionInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.RegionInfoResponse)
}

func (p *RegionInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func regionSizeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.RegionSizeRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).RegionSize(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RegionSizeArgs:
		success, err := handler.(debugpb.Debug).RegionSize(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RegionSizeResult)
		realResult.Success = success
	}
	return nil
}
func newRegionSizeArgs() interface{} {
	return &RegionSizeArgs{}
}

func newRegionSizeResult() interface{} {
	return &RegionSizeResult{}
}

type RegionSizeArgs struct {
	Req *debugpb.RegionSizeRequest
}

func (p *RegionSizeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RegionSizeArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RegionSizeArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.RegionSizeRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RegionSizeArgs_Req_DEFAULT *debugpb.RegionSizeRequest

func (p *RegionSizeArgs) GetReq() *debugpb.RegionSizeRequest {
	if !p.IsSetReq() {
		return RegionSizeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RegionSizeArgs) IsSetReq() bool {
	return p.Req != nil
}

type RegionSizeResult struct {
	Success *debugpb.RegionSizeResponse
}

var RegionSizeResult_Success_DEFAULT *debugpb.RegionSizeResponse

func (p *RegionSizeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RegionSizeResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RegionSizeResult) Unmarshal(in []byte) error {
	msg := new(debugpb.RegionSizeResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RegionSizeResult) GetSuccess() *debugpb.RegionSizeResponse {
	if !p.IsSetSuccess() {
		return RegionSizeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RegionSizeResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.RegionSizeResponse)
}

func (p *RegionSizeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func scanMvccHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &debugScanMvccServer{st}
	req := new(debugpb.ScanMvccRequest)
	if err := st.RecvMsg(req); err != nil {
		return err
	}
	return handler.(debugpb.Debug).ScanMvcc(req, stream)
}

type debugScanMvccClient struct {
	streaming.Stream
}

func (x *debugScanMvccClient) Recv() (*debugpb.ScanMvccResponse, error) {
	m := new(debugpb.ScanMvccResponse)
	return m, x.Stream.RecvMsg(m)
}

type debugScanMvccServer struct {
	streaming.Stream
}

func (x *debugScanMvccServer) Send(m *debugpb.ScanMvccResponse) error {
	return x.Stream.SendMsg(m)
}

func newScanMvccArgs() interface{} {
	return &ScanMvccArgs{}
}

func newScanMvccResult() interface{} {
	return &ScanMvccResult{}
}

type ScanMvccArgs struct {
	Req *debugpb.ScanMvccRequest
}

func (p *ScanMvccArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ScanMvccArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ScanMvccArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.ScanMvccRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ScanMvccArgs_Req_DEFAULT *debugpb.ScanMvccRequest

func (p *ScanMvccArgs) GetReq() *debugpb.ScanMvccRequest {
	if !p.IsSetReq() {
		return ScanMvccArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ScanMvccArgs) IsSetReq() bool {
	return p.Req != nil
}

type ScanMvccResult struct {
	Success *debugpb.ScanMvccResponse
}

var ScanMvccResult_Success_DEFAULT *debugpb.ScanMvccResponse

func (p *ScanMvccResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ScanMvccResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ScanMvccResult) Unmarshal(in []byte) error {
	msg := new(debugpb.ScanMvccResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ScanMvccResult) GetSuccess() *debugpb.ScanMvccResponse {
	if !p.IsSetSuccess() {
		return ScanMvccResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ScanMvccResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.ScanMvccResponse)
}

func (p *ScanMvccResult) IsSetSuccess() bool {
	return p.Success != nil
}

func compactHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.CompactRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).Compact(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CompactArgs:
		success, err := handler.(debugpb.Debug).Compact(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompactResult)
		realResult.Success = success
	}
	return nil
}
func newCompactArgs() interface{} {
	return &CompactArgs{}
}

func newCompactResult() interface{} {
	return &CompactResult{}
}

type CompactArgs struct {
	Req *debugpb.CompactRequest
}

func (p *CompactArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CompactArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CompactArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.CompactRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompactArgs_Req_DEFAULT *debugpb.CompactRequest

func (p *CompactArgs) GetReq() *debugpb.CompactRequest {
	if !p.IsSetReq() {
		return CompactArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompactArgs) IsSetReq() bool {
	return p.Req != nil
}

type CompactResult struct {
	Success *debugpb.CompactResponse
}

var CompactResult_Success_DEFAULT *debugpb.CompactResponse

func (p *CompactResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CompactResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CompactResult) Unmarshal(in []byte) error {
	msg := new(debugpb.CompactResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompactResult) GetSuccess() *debugpb.CompactResponse {
	if !p.IsSetSuccess() {
		return CompactResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompactResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.CompactResponse)
}

func (p *CompactResult) IsSetSuccess() bool {
	return p.Success != nil
}

func injectFailPointHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.InjectFailPointRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).InjectFailPoint(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *InjectFailPointArgs:
		success, err := handler.(debugpb.Debug).InjectFailPoint(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*InjectFailPointResult)
		realResult.Success = success
	}
	return nil
}
func newInjectFailPointArgs() interface{} {
	return &InjectFailPointArgs{}
}

func newInjectFailPointResult() interface{} {
	return &InjectFailPointResult{}
}

type InjectFailPointArgs struct {
	Req *debugpb.InjectFailPointRequest
}

func (p *InjectFailPointArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in InjectFailPointArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *InjectFailPointArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.InjectFailPointRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var InjectFailPointArgs_Req_DEFAULT *debugpb.InjectFailPointRequest

func (p *InjectFailPointArgs) GetReq() *debugpb.InjectFailPointRequest {
	if !p.IsSetReq() {
		return InjectFailPointArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *InjectFailPointArgs) IsSetReq() bool {
	return p.Req != nil
}

type InjectFailPointResult struct {
	Success *debugpb.InjectFailPointResponse
}

var InjectFailPointResult_Success_DEFAULT *debugpb.InjectFailPointResponse

func (p *InjectFailPointResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in InjectFailPointResult")
	}
	return proto.Marshal(p.Success)
}

func (p *InjectFailPointResult) Unmarshal(in []byte) error {
	msg := new(debugpb.InjectFailPointResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *InjectFailPointResult) GetSuccess() *debugpb.InjectFailPointResponse {
	if !p.IsSetSuccess() {
		return InjectFailPointResult_Success_DEFAULT
	}
	return p.Success
}

func (p *InjectFailPointResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.InjectFailPointResponse)
}

func (p *InjectFailPointResult) IsSetSuccess() bool {
	return p.Success != nil
}

func recoverFailPointHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.RecoverFailPointRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).RecoverFailPoint(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RecoverFailPointArgs:
		success, err := handler.(debugpb.Debug).RecoverFailPoint(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RecoverFailPointResult)
		realResult.Success = success
	}
	return nil
}
func newRecoverFailPointArgs() interface{} {
	return &RecoverFailPointArgs{}
}

func newRecoverFailPointResult() interface{} {
	return &RecoverFailPointResult{}
}

type RecoverFailPointArgs struct {
	Req *debugpb.RecoverFailPointRequest
}

func (p *RecoverFailPointArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RecoverFailPointArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RecoverFailPointArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.RecoverFailPointRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RecoverFailPointArgs_Req_DEFAULT *debugpb.RecoverFailPointRequest

func (p *RecoverFailPointArgs) GetReq() *debugpb.RecoverFailPointRequest {
	if !p.IsSetReq() {
		return RecoverFailPointArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RecoverFailPointArgs) IsSetReq() bool {
	return p.Req != nil
}

type RecoverFailPointResult struct {
	Success *debugpb.RecoverFailPointResponse
}

var RecoverFailPointResult_Success_DEFAULT *debugpb.RecoverFailPointResponse

func (p *RecoverFailPointResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RecoverFailPointResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RecoverFailPointResult) Unmarshal(in []byte) error {
	msg := new(debugpb.RecoverFailPointResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RecoverFailPointResult) GetSuccess() *debugpb.RecoverFailPointResponse {
	if !p.IsSetSuccess() {
		return RecoverFailPointResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RecoverFailPointResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.RecoverFailPointResponse)
}

func (p *RecoverFailPointResult) IsSetSuccess() bool {
	return p.Success != nil
}

func listFailPointsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.ListFailPointsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).ListFailPoints(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ListFailPointsArgs:
		success, err := handler.(debugpb.Debug).ListFailPoints(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ListFailPointsResult)
		realResult.Success = success
	}
	return nil
}
func newListFailPointsArgs() interface{} {
	return &ListFailPointsArgs{}
}

func newListFailPointsResult() interface{} {
	return &ListFailPointsResult{}
}

type ListFailPointsArgs struct {
	Req *debugpb.ListFailPointsRequest
}

func (p *ListFailPointsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ListFailPointsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ListFailPointsArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.ListFailPointsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ListFailPointsArgs_Req_DEFAULT *debugpb.ListFailPointsRequest

func (p *ListFailPointsArgs) GetReq() *debugpb.ListFailPointsRequest {
	if !p.IsSetReq() {
		return ListFailPointsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ListFailPointsArgs) IsSetReq() bool {
	return p.Req != nil
}

type ListFailPointsResult struct {
	Success *debugpb.ListFailPointsResponse
}

var ListFailPointsResult_Success_DEFAULT *debugpb.ListFailPointsResponse

func (p *ListFailPointsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ListFailPointsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ListFailPointsResult) Unmarshal(in []byte) error {
	msg := new(debugpb.ListFailPointsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ListFailPointsResult) GetSuccess() *debugpb.ListFailPointsResponse {
	if !p.IsSetSuccess() {
		return ListFailPointsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ListFailPointsResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.ListFailPointsResponse)
}

func (p *ListFailPointsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getMetricsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.GetMetricsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).GetMetrics(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetMetricsArgs:
		success, err := handler.(debugpb.Debug).GetMetrics(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetMetricsResult)
		realResult.Success = success
	}
	return nil
}
func newGetMetricsArgs() interface{} {
	return &GetMetricsArgs{}
}

func newGetMetricsResult() interface{} {
	return &GetMetricsResult{}
}

type GetMetricsArgs struct {
	Req *debugpb.GetMetricsRequest
}

func (p *GetMetricsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetMetricsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetMetricsArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.GetMetricsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetMetricsArgs_Req_DEFAULT *debugpb.GetMetricsRequest

func (p *GetMetricsArgs) GetReq() *debugpb.GetMetricsRequest {
	if !p.IsSetReq() {
		return GetMetricsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetMetricsArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetMetricsResult struct {
	Success *debugpb.GetMetricsResponse
}

var GetMetricsResult_Success_DEFAULT *debugpb.GetMetricsResponse

func (p *GetMetricsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetMetricsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetMetricsResult) Unmarshal(in []byte) error {
	msg := new(debugpb.GetMetricsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetMetricsResult) GetSuccess() *debugpb.GetMetricsResponse {
	if !p.IsSetSuccess() {
		return GetMetricsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetMetricsResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.GetMetricsResponse)
}

func (p *GetMetricsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func checkRegionConsistencyHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.RegionConsistencyCheckRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).CheckRegionConsistency(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CheckRegionConsistencyArgs:
		success, err := handler.(debugpb.Debug).CheckRegionConsistency(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CheckRegionConsistencyResult)
		realResult.Success = success
	}
	return nil
}
func newCheckRegionConsistencyArgs() interface{} {
	return &CheckRegionConsistencyArgs{}
}

func newCheckRegionConsistencyResult() interface{} {
	return &CheckRegionConsistencyResult{}
}

type CheckRegionConsistencyArgs struct {
	Req *debugpb.RegionConsistencyCheckRequest
}

func (p *CheckRegionConsistencyArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CheckRegionConsistencyArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CheckRegionConsistencyArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.RegionConsistencyCheckRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CheckRegionConsistencyArgs_Req_DEFAULT *debugpb.RegionConsistencyCheckRequest

func (p *CheckRegionConsistencyArgs) GetReq() *debugpb.RegionConsistencyCheckRequest {
	if !p.IsSetReq() {
		return CheckRegionConsistencyArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CheckRegionConsistencyArgs) IsSetReq() bool {
	return p.Req != nil
}

type CheckRegionConsistencyResult struct {
	Success *debugpb.RegionConsistencyCheckResponse
}

var CheckRegionConsistencyResult_Success_DEFAULT *debugpb.RegionConsistencyCheckResponse

func (p *CheckRegionConsistencyResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CheckRegionConsistencyResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CheckRegionConsistencyResult) Unmarshal(in []byte) error {
	msg := new(debugpb.RegionConsistencyCheckResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CheckRegionConsistencyResult) GetSuccess() *debugpb.RegionConsistencyCheckResponse {
	if !p.IsSetSuccess() {
		return CheckRegionConsistencyResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CheckRegionConsistencyResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.RegionConsistencyCheckResponse)
}

func (p *CheckRegionConsistencyResult) IsSetSuccess() bool {
	return p.Success != nil
}

func modifyTikvConfigHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.ModifyTikvConfigRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).ModifyTikvConfig(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ModifyTikvConfigArgs:
		success, err := handler.(debugpb.Debug).ModifyTikvConfig(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ModifyTikvConfigResult)
		realResult.Success = success
	}
	return nil
}
func newModifyTikvConfigArgs() interface{} {
	return &ModifyTikvConfigArgs{}
}

func newModifyTikvConfigResult() interface{} {
	return &ModifyTikvConfigResult{}
}

type ModifyTikvConfigArgs struct {
	Req *debugpb.ModifyTikvConfigRequest
}

func (p *ModifyTikvConfigArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ModifyTikvConfigArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ModifyTikvConfigArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.ModifyTikvConfigRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ModifyTikvConfigArgs_Req_DEFAULT *debugpb.ModifyTikvConfigRequest

func (p *ModifyTikvConfigArgs) GetReq() *debugpb.ModifyTikvConfigRequest {
	if !p.IsSetReq() {
		return ModifyTikvConfigArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ModifyTikvConfigArgs) IsSetReq() bool {
	return p.Req != nil
}

type ModifyTikvConfigResult struct {
	Success *debugpb.ModifyTikvConfigResponse
}

var ModifyTikvConfigResult_Success_DEFAULT *debugpb.ModifyTikvConfigResponse

func (p *ModifyTikvConfigResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ModifyTikvConfigResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ModifyTikvConfigResult) Unmarshal(in []byte) error {
	msg := new(debugpb.ModifyTikvConfigResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ModifyTikvConfigResult) GetSuccess() *debugpb.ModifyTikvConfigResponse {
	if !p.IsSetSuccess() {
		return ModifyTikvConfigResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ModifyTikvConfigResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.ModifyTikvConfigResponse)
}

func (p *ModifyTikvConfigResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getRegionPropertiesHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.GetRegionPropertiesRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).GetRegionProperties(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetRegionPropertiesArgs:
		success, err := handler.(debugpb.Debug).GetRegionProperties(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetRegionPropertiesResult)
		realResult.Success = success
	}
	return nil
}
func newGetRegionPropertiesArgs() interface{} {
	return &GetRegionPropertiesArgs{}
}

func newGetRegionPropertiesResult() interface{} {
	return &GetRegionPropertiesResult{}
}

type GetRegionPropertiesArgs struct {
	Req *debugpb.GetRegionPropertiesRequest
}

func (p *GetRegionPropertiesArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetRegionPropertiesArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetRegionPropertiesArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.GetRegionPropertiesRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetRegionPropertiesArgs_Req_DEFAULT *debugpb.GetRegionPropertiesRequest

func (p *GetRegionPropertiesArgs) GetReq() *debugpb.GetRegionPropertiesRequest {
	if !p.IsSetReq() {
		return GetRegionPropertiesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetRegionPropertiesArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetRegionPropertiesResult struct {
	Success *debugpb.GetRegionPropertiesResponse
}

var GetRegionPropertiesResult_Success_DEFAULT *debugpb.GetRegionPropertiesResponse

func (p *GetRegionPropertiesResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetRegionPropertiesResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetRegionPropertiesResult) Unmarshal(in []byte) error {
	msg := new(debugpb.GetRegionPropertiesResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetRegionPropertiesResult) GetSuccess() *debugpb.GetRegionPropertiesResponse {
	if !p.IsSetSuccess() {
		return GetRegionPropertiesResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetRegionPropertiesResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.GetRegionPropertiesResponse)
}

func (p *GetRegionPropertiesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getStoreInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.GetStoreInfoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).GetStoreInfo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetStoreInfoArgs:
		success, err := handler.(debugpb.Debug).GetStoreInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetStoreInfoResult)
		realResult.Success = success
	}
	return nil
}
func newGetStoreInfoArgs() interface{} {
	return &GetStoreInfoArgs{}
}

func newGetStoreInfoResult() interface{} {
	return &GetStoreInfoResult{}
}

type GetStoreInfoArgs struct {
	Req *debugpb.GetStoreInfoRequest
}

func (p *GetStoreInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetStoreInfoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetStoreInfoArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.GetStoreInfoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetStoreInfoArgs_Req_DEFAULT *debugpb.GetStoreInfoRequest

func (p *GetStoreInfoArgs) GetReq() *debugpb.GetStoreInfoRequest {
	if !p.IsSetReq() {
		return GetStoreInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetStoreInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetStoreInfoResult struct {
	Success *debugpb.GetStoreInfoResponse
}

var GetStoreInfoResult_Success_DEFAULT *debugpb.GetStoreInfoResponse

func (p *GetStoreInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetStoreInfoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetStoreInfoResult) Unmarshal(in []byte) error {
	msg := new(debugpb.GetStoreInfoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetStoreInfoResult) GetSuccess() *debugpb.GetStoreInfoResponse {
	if !p.IsSetSuccess() {
		return GetStoreInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetStoreInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.GetStoreInfoResponse)
}

func (p *GetStoreInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getClusterInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.GetClusterInfoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).GetClusterInfo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetClusterInfoArgs:
		success, err := handler.(debugpb.Debug).GetClusterInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetClusterInfoResult)
		realResult.Success = success
	}
	return nil
}
func newGetClusterInfoArgs() interface{} {
	return &GetClusterInfoArgs{}
}

func newGetClusterInfoResult() interface{} {
	return &GetClusterInfoResult{}
}

type GetClusterInfoArgs struct {
	Req *debugpb.GetClusterInfoRequest
}

func (p *GetClusterInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetClusterInfoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetClusterInfoArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.GetClusterInfoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetClusterInfoArgs_Req_DEFAULT *debugpb.GetClusterInfoRequest

func (p *GetClusterInfoArgs) GetReq() *debugpb.GetClusterInfoRequest {
	if !p.IsSetReq() {
		return GetClusterInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetClusterInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetClusterInfoResult struct {
	Success *debugpb.GetClusterInfoResponse
}

var GetClusterInfoResult_Success_DEFAULT *debugpb.GetClusterInfoResponse

func (p *GetClusterInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetClusterInfoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetClusterInfoResult) Unmarshal(in []byte) error {
	msg := new(debugpb.GetClusterInfoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetClusterInfoResult) GetSuccess() *debugpb.GetClusterInfoResponse {
	if !p.IsSetSuccess() {
		return GetClusterInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetClusterInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.GetClusterInfoResponse)
}

func (p *GetClusterInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getAllRegionsInStoreHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(debugpb.GetAllRegionsInStoreRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(debugpb.Debug).GetAllRegionsInStore(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetAllRegionsInStoreArgs:
		success, err := handler.(debugpb.Debug).GetAllRegionsInStore(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetAllRegionsInStoreResult)
		realResult.Success = success
	}
	return nil
}
func newGetAllRegionsInStoreArgs() interface{} {
	return &GetAllRegionsInStoreArgs{}
}

func newGetAllRegionsInStoreResult() interface{} {
	return &GetAllRegionsInStoreResult{}
}

type GetAllRegionsInStoreArgs struct {
	Req *debugpb.GetAllRegionsInStoreRequest
}

func (p *GetAllRegionsInStoreArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetAllRegionsInStoreArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetAllRegionsInStoreArgs) Unmarshal(in []byte) error {
	msg := new(debugpb.GetAllRegionsInStoreRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetAllRegionsInStoreArgs_Req_DEFAULT *debugpb.GetAllRegionsInStoreRequest

func (p *GetAllRegionsInStoreArgs) GetReq() *debugpb.GetAllRegionsInStoreRequest {
	if !p.IsSetReq() {
		return GetAllRegionsInStoreArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetAllRegionsInStoreArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetAllRegionsInStoreResult struct {
	Success *debugpb.GetAllRegionsInStoreResponse
}

var GetAllRegionsInStoreResult_Success_DEFAULT *debugpb.GetAllRegionsInStoreResponse

func (p *GetAllRegionsInStoreResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetAllRegionsInStoreResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetAllRegionsInStoreResult) Unmarshal(in []byte) error {
	msg := new(debugpb.GetAllRegionsInStoreResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetAllRegionsInStoreResult) GetSuccess() *debugpb.GetAllRegionsInStoreResponse {
	if !p.IsSetSuccess() {
		return GetAllRegionsInStoreResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetAllRegionsInStoreResult) SetSuccess(x interface{}) {
	p.Success = x.(*debugpb.GetAllRegionsInStoreResponse)
}

func (p *GetAllRegionsInStoreResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) Get(ctx context.Context, Req *debugpb.GetRequest) (r *debugpb.GetResponse, err error) {
	var _args GetArgs
	_args.Req = Req
	var _result GetResult
	if err = p.c.Call(ctx, "Get", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RaftLog(ctx context.Context, Req *debugpb.RaftLogRequest) (r *debugpb.RaftLogResponse, err error) {
	var _args RaftLogArgs
	_args.Req = Req
	var _result RaftLogResult
	if err = p.c.Call(ctx, "RaftLog", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RegionInfo(ctx context.Context, Req *debugpb.RegionInfoRequest) (r *debugpb.RegionInfoResponse, err error) {
	var _args RegionInfoArgs
	_args.Req = Req
	var _result RegionInfoResult
	if err = p.c.Call(ctx, "RegionInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RegionSize(ctx context.Context, Req *debugpb.RegionSizeRequest) (r *debugpb.RegionSizeResponse, err error) {
	var _args RegionSizeArgs
	_args.Req = Req
	var _result RegionSizeResult
	if err = p.c.Call(ctx, "RegionSize", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ScanMvcc(ctx context.Context, req *debugpb.ScanMvccRequest) (Debug_ScanMvccClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "ScanMvcc", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &debugScanMvccClient{res.Stream}
	if err := stream.Stream.SendMsg(req); err != nil {
		return nil, err
	}
	if err := stream.Stream.Close(); err != nil {
		return nil, err
	}
	return stream, nil
}

func (p *kClient) Compact(ctx context.Context, Req *debugpb.CompactRequest) (r *debugpb.CompactResponse, err error) {
	var _args CompactArgs
	_args.Req = Req
	var _result CompactResult
	if err = p.c.Call(ctx, "Compact", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) InjectFailPoint(ctx context.Context, Req *debugpb.InjectFailPointRequest) (r *debugpb.InjectFailPointResponse, err error) {
	var _args InjectFailPointArgs
	_args.Req = Req
	var _result InjectFailPointResult
	if err = p.c.Call(ctx, "InjectFailPoint", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RecoverFailPoint(ctx context.Context, Req *debugpb.RecoverFailPointRequest) (r *debugpb.RecoverFailPointResponse, err error) {
	var _args RecoverFailPointArgs
	_args.Req = Req
	var _result RecoverFailPointResult
	if err = p.c.Call(ctx, "RecoverFailPoint", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ListFailPoints(ctx context.Context, Req *debugpb.ListFailPointsRequest) (r *debugpb.ListFailPointsResponse, err error) {
	var _args ListFailPointsArgs
	_args.Req = Req
	var _result ListFailPointsResult
	if err = p.c.Call(ctx, "ListFailPoints", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetMetrics(ctx context.Context, Req *debugpb.GetMetricsRequest) (r *debugpb.GetMetricsResponse, err error) {
	var _args GetMetricsArgs
	_args.Req = Req
	var _result GetMetricsResult
	if err = p.c.Call(ctx, "GetMetrics", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CheckRegionConsistency(ctx context.Context, Req *debugpb.RegionConsistencyCheckRequest) (r *debugpb.RegionConsistencyCheckResponse, err error) {
	var _args CheckRegionConsistencyArgs
	_args.Req = Req
	var _result CheckRegionConsistencyResult
	if err = p.c.Call(ctx, "CheckRegionConsistency", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ModifyTikvConfig(ctx context.Context, Req *debugpb.ModifyTikvConfigRequest) (r *debugpb.ModifyTikvConfigResponse, err error) {
	var _args ModifyTikvConfigArgs
	_args.Req = Req
	var _result ModifyTikvConfigResult
	if err = p.c.Call(ctx, "ModifyTikvConfig", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetRegionProperties(ctx context.Context, Req *debugpb.GetRegionPropertiesRequest) (r *debugpb.GetRegionPropertiesResponse, err error) {
	var _args GetRegionPropertiesArgs
	_args.Req = Req
	var _result GetRegionPropertiesResult
	if err = p.c.Call(ctx, "GetRegionProperties", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetStoreInfo(ctx context.Context, Req *debugpb.GetStoreInfoRequest) (r *debugpb.GetStoreInfoResponse, err error) {
	var _args GetStoreInfoArgs
	_args.Req = Req
	var _result GetStoreInfoResult
	if err = p.c.Call(ctx, "GetStoreInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetClusterInfo(ctx context.Context, Req *debugpb.GetClusterInfoRequest) (r *debugpb.GetClusterInfoResponse, err error) {
	var _args GetClusterInfoArgs
	_args.Req = Req
	var _result GetClusterInfoResult
	if err = p.c.Call(ctx, "GetClusterInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetAllRegionsInStore(ctx context.Context, Req *debugpb.GetAllRegionsInStoreRequest) (r *debugpb.GetAllRegionsInStoreResponse, err error) {
	var _args GetAllRegionsInStoreArgs
	_args.Req = Req
	var _result GetAllRegionsInStoreResult
	if err = p.c.Call(ctx, "GetAllRegionsInStore", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
