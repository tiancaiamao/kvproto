// Code generated by Kitex v0.1.3. DO NOT EDIT.

package pd

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/pingcap/kvproto/proto/kitex_gen/pdpb"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return pDServiceInfo
}

var pDServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "PD"
	handlerType := (*pdpb.PD)(nil)
	methods := map[string]kitex.MethodInfo{
		"GetMembers":               kitex.NewMethodInfo(getMembersHandler, newGetMembersArgs, newGetMembersResult, false),
		"Tso":                      kitex.NewMethodInfo(tsoHandler, newTsoArgs, newTsoResult, false),
		"Bootstrap":                kitex.NewMethodInfo(bootstrapHandler, newBootstrapArgs, newBootstrapResult, false),
		"IsBootstrapped":           kitex.NewMethodInfo(isBootstrappedHandler, newIsBootstrappedArgs, newIsBootstrappedResult, false),
		"AllocID":                  kitex.NewMethodInfo(allocIDHandler, newAllocIDArgs, newAllocIDResult, false),
		"GetStore":                 kitex.NewMethodInfo(getStoreHandler, newGetStoreArgs, newGetStoreResult, false),
		"PutStore":                 kitex.NewMethodInfo(putStoreHandler, newPutStoreArgs, newPutStoreResult, false),
		"GetAllStores":             kitex.NewMethodInfo(getAllStoresHandler, newGetAllStoresArgs, newGetAllStoresResult, false),
		"StoreHeartbeat":           kitex.NewMethodInfo(storeHeartbeatHandler, newStoreHeartbeatArgs, newStoreHeartbeatResult, false),
		"RegionHeartbeat":          kitex.NewMethodInfo(regionHeartbeatHandler, newRegionHeartbeatArgs, newRegionHeartbeatResult, false),
		"GetRegion":                kitex.NewMethodInfo(getRegionHandler, newGetRegionArgs, newGetRegionResult, false),
		"GetPrevRegion":            kitex.NewMethodInfo(getPrevRegionHandler, newGetPrevRegionArgs, newGetPrevRegionResult, false),
		"GetRegionByID":            kitex.NewMethodInfo(getRegionByIDHandler, newGetRegionByIDArgs, newGetRegionByIDResult, false),
		"ScanRegions":              kitex.NewMethodInfo(scanRegionsHandler, newScanRegionsArgs, newScanRegionsResult, false),
		"AskSplit":                 kitex.NewMethodInfo(askSplitHandler, newAskSplitArgs, newAskSplitResult, false),
		"ReportSplit":              kitex.NewMethodInfo(reportSplitHandler, newReportSplitArgs, newReportSplitResult, false),
		"AskBatchSplit":            kitex.NewMethodInfo(askBatchSplitHandler, newAskBatchSplitArgs, newAskBatchSplitResult, false),
		"ReportBatchSplit":         kitex.NewMethodInfo(reportBatchSplitHandler, newReportBatchSplitArgs, newReportBatchSplitResult, false),
		"GetClusterConfig":         kitex.NewMethodInfo(getClusterConfigHandler, newGetClusterConfigArgs, newGetClusterConfigResult, false),
		"PutClusterConfig":         kitex.NewMethodInfo(putClusterConfigHandler, newPutClusterConfigArgs, newPutClusterConfigResult, false),
		"ScatterRegion":            kitex.NewMethodInfo(scatterRegionHandler, newScatterRegionArgs, newScatterRegionResult, false),
		"GetGCSafePoint":           kitex.NewMethodInfo(getGCSafePointHandler, newGetGCSafePointArgs, newGetGCSafePointResult, false),
		"UpdateGCSafePoint":        kitex.NewMethodInfo(updateGCSafePointHandler, newUpdateGCSafePointArgs, newUpdateGCSafePointResult, false),
		"UpdateServiceGCSafePoint": kitex.NewMethodInfo(updateServiceGCSafePointHandler, newUpdateServiceGCSafePointArgs, newUpdateServiceGCSafePointResult, false),
		"SyncRegions":              kitex.NewMethodInfo(syncRegionsHandler, newSyncRegionsArgs, newSyncRegionsResult, false),
		"GetOperator":              kitex.NewMethodInfo(getOperatorHandler, newGetOperatorArgs, newGetOperatorResult, false),
		"SyncMaxTS":                kitex.NewMethodInfo(syncMaxTSHandler, newSyncMaxTSArgs, newSyncMaxTSResult, false),
		"SplitRegions":             kitex.NewMethodInfo(splitRegionsHandler, newSplitRegionsArgs, newSplitRegionsResult, false),
		"SplitAndScatterRegions":   kitex.NewMethodInfo(splitAndScatterRegionsHandler, newSplitAndScatterRegionsArgs, newSplitAndScatterRegionsResult, false),
		"GetDCLocationInfo":        kitex.NewMethodInfo(getDCLocationInfoHandler, newGetDCLocationInfoArgs, newGetDCLocationInfoResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "pdpb",
	}
	extra["streaming"] = true
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.1.3",
		Extra:           extra,
	}
	return svcInfo
}

func getMembersHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetMembersRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetMembers(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetMembersArgs:
		success, err := handler.(pdpb.PD).GetMembers(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetMembersResult)
		realResult.Success = success
	}
	return nil
}
func newGetMembersArgs() interface{} {
	return &GetMembersArgs{}
}

func newGetMembersResult() interface{} {
	return &GetMembersResult{}
}

type GetMembersArgs struct {
	Req *pdpb.GetMembersRequest
}

func (p *GetMembersArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetMembersArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetMembersArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetMembersRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetMembersArgs_Req_DEFAULT *pdpb.GetMembersRequest

func (p *GetMembersArgs) GetReq() *pdpb.GetMembersRequest {
	if !p.IsSetReq() {
		return GetMembersArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetMembersArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetMembersResult struct {
	Success *pdpb.GetMembersResponse
}

var GetMembersResult_Success_DEFAULT *pdpb.GetMembersResponse

func (p *GetMembersResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetMembersResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetMembersResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetMembersResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetMembersResult) GetSuccess() *pdpb.GetMembersResponse {
	if !p.IsSetSuccess() {
		return GetMembersResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetMembersResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetMembersResponse)
}

func (p *GetMembersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func tsoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &pDTsoServer{st}
	return handler.(pdpb.PD).Tso(stream)
}

type pDTsoClient struct {
	streaming.Stream
}

func (x *pDTsoClient) Send(m *pdpb.TsoRequest) error {
	return x.Stream.SendMsg(m)
}
func (x *pDTsoClient) Recv() (*pdpb.TsoResponse, error) {
	m := new(pdpb.TsoResponse)
	return m, x.Stream.RecvMsg(m)
}

type pDTsoServer struct {
	streaming.Stream
}

func (x *pDTsoServer) Send(m *pdpb.TsoResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *pDTsoServer) Recv() (*pdpb.TsoRequest, error) {
	m := new(pdpb.TsoRequest)
	return m, x.Stream.RecvMsg(m)
}

func newTsoArgs() interface{} {
	return &TsoArgs{}
}

func newTsoResult() interface{} {
	return &TsoResult{}
}

type TsoArgs struct {
	Req *pdpb.TsoRequest
}

func (p *TsoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in TsoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *TsoArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.TsoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var TsoArgs_Req_DEFAULT *pdpb.TsoRequest

func (p *TsoArgs) GetReq() *pdpb.TsoRequest {
	if !p.IsSetReq() {
		return TsoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *TsoArgs) IsSetReq() bool {
	return p.Req != nil
}

type TsoResult struct {
	Success *pdpb.TsoResponse
}

var TsoResult_Success_DEFAULT *pdpb.TsoResponse

func (p *TsoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in TsoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *TsoResult) Unmarshal(in []byte) error {
	msg := new(pdpb.TsoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *TsoResult) GetSuccess() *pdpb.TsoResponse {
	if !p.IsSetSuccess() {
		return TsoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *TsoResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.TsoResponse)
}

func (p *TsoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func bootstrapHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.BootstrapRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).Bootstrap(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *BootstrapArgs:
		success, err := handler.(pdpb.PD).Bootstrap(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*BootstrapResult)
		realResult.Success = success
	}
	return nil
}
func newBootstrapArgs() interface{} {
	return &BootstrapArgs{}
}

func newBootstrapResult() interface{} {
	return &BootstrapResult{}
}

type BootstrapArgs struct {
	Req *pdpb.BootstrapRequest
}

func (p *BootstrapArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in BootstrapArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *BootstrapArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.BootstrapRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var BootstrapArgs_Req_DEFAULT *pdpb.BootstrapRequest

func (p *BootstrapArgs) GetReq() *pdpb.BootstrapRequest {
	if !p.IsSetReq() {
		return BootstrapArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *BootstrapArgs) IsSetReq() bool {
	return p.Req != nil
}

type BootstrapResult struct {
	Success *pdpb.BootstrapResponse
}

var BootstrapResult_Success_DEFAULT *pdpb.BootstrapResponse

func (p *BootstrapResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in BootstrapResult")
	}
	return proto.Marshal(p.Success)
}

func (p *BootstrapResult) Unmarshal(in []byte) error {
	msg := new(pdpb.BootstrapResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *BootstrapResult) GetSuccess() *pdpb.BootstrapResponse {
	if !p.IsSetSuccess() {
		return BootstrapResult_Success_DEFAULT
	}
	return p.Success
}

func (p *BootstrapResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.BootstrapResponse)
}

func (p *BootstrapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func isBootstrappedHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.IsBootstrappedRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).IsBootstrapped(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *IsBootstrappedArgs:
		success, err := handler.(pdpb.PD).IsBootstrapped(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*IsBootstrappedResult)
		realResult.Success = success
	}
	return nil
}
func newIsBootstrappedArgs() interface{} {
	return &IsBootstrappedArgs{}
}

func newIsBootstrappedResult() interface{} {
	return &IsBootstrappedResult{}
}

type IsBootstrappedArgs struct {
	Req *pdpb.IsBootstrappedRequest
}

func (p *IsBootstrappedArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in IsBootstrappedArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *IsBootstrappedArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.IsBootstrappedRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var IsBootstrappedArgs_Req_DEFAULT *pdpb.IsBootstrappedRequest

func (p *IsBootstrappedArgs) GetReq() *pdpb.IsBootstrappedRequest {
	if !p.IsSetReq() {
		return IsBootstrappedArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *IsBootstrappedArgs) IsSetReq() bool {
	return p.Req != nil
}

type IsBootstrappedResult struct {
	Success *pdpb.IsBootstrappedResponse
}

var IsBootstrappedResult_Success_DEFAULT *pdpb.IsBootstrappedResponse

func (p *IsBootstrappedResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in IsBootstrappedResult")
	}
	return proto.Marshal(p.Success)
}

func (p *IsBootstrappedResult) Unmarshal(in []byte) error {
	msg := new(pdpb.IsBootstrappedResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *IsBootstrappedResult) GetSuccess() *pdpb.IsBootstrappedResponse {
	if !p.IsSetSuccess() {
		return IsBootstrappedResult_Success_DEFAULT
	}
	return p.Success
}

func (p *IsBootstrappedResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.IsBootstrappedResponse)
}

func (p *IsBootstrappedResult) IsSetSuccess() bool {
	return p.Success != nil
}

func allocIDHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.AllocIDRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).AllocID(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AllocIDArgs:
		success, err := handler.(pdpb.PD).AllocID(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AllocIDResult)
		realResult.Success = success
	}
	return nil
}
func newAllocIDArgs() interface{} {
	return &AllocIDArgs{}
}

func newAllocIDResult() interface{} {
	return &AllocIDResult{}
}

type AllocIDArgs struct {
	Req *pdpb.AllocIDRequest
}

func (p *AllocIDArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in AllocIDArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *AllocIDArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.AllocIDRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AllocIDArgs_Req_DEFAULT *pdpb.AllocIDRequest

func (p *AllocIDArgs) GetReq() *pdpb.AllocIDRequest {
	if !p.IsSetReq() {
		return AllocIDArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AllocIDArgs) IsSetReq() bool {
	return p.Req != nil
}

type AllocIDResult struct {
	Success *pdpb.AllocIDResponse
}

var AllocIDResult_Success_DEFAULT *pdpb.AllocIDResponse

func (p *AllocIDResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in AllocIDResult")
	}
	return proto.Marshal(p.Success)
}

func (p *AllocIDResult) Unmarshal(in []byte) error {
	msg := new(pdpb.AllocIDResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AllocIDResult) GetSuccess() *pdpb.AllocIDResponse {
	if !p.IsSetSuccess() {
		return AllocIDResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AllocIDResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.AllocIDResponse)
}

func (p *AllocIDResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getStoreHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetStoreRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetStore(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetStoreArgs:
		success, err := handler.(pdpb.PD).GetStore(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetStoreResult)
		realResult.Success = success
	}
	return nil
}
func newGetStoreArgs() interface{} {
	return &GetStoreArgs{}
}

func newGetStoreResult() interface{} {
	return &GetStoreResult{}
}

type GetStoreArgs struct {
	Req *pdpb.GetStoreRequest
}

func (p *GetStoreArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetStoreArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetStoreArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetStoreRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetStoreArgs_Req_DEFAULT *pdpb.GetStoreRequest

func (p *GetStoreArgs) GetReq() *pdpb.GetStoreRequest {
	if !p.IsSetReq() {
		return GetStoreArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetStoreArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetStoreResult struct {
	Success *pdpb.GetStoreResponse
}

var GetStoreResult_Success_DEFAULT *pdpb.GetStoreResponse

func (p *GetStoreResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetStoreResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetStoreResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetStoreResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetStoreResult) GetSuccess() *pdpb.GetStoreResponse {
	if !p.IsSetSuccess() {
		return GetStoreResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetStoreResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetStoreResponse)
}

func (p *GetStoreResult) IsSetSuccess() bool {
	return p.Success != nil
}

func putStoreHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.PutStoreRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).PutStore(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *PutStoreArgs:
		success, err := handler.(pdpb.PD).PutStore(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PutStoreResult)
		realResult.Success = success
	}
	return nil
}
func newPutStoreArgs() interface{} {
	return &PutStoreArgs{}
}

func newPutStoreResult() interface{} {
	return &PutStoreResult{}
}

type PutStoreArgs struct {
	Req *pdpb.PutStoreRequest
}

func (p *PutStoreArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in PutStoreArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *PutStoreArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.PutStoreRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PutStoreArgs_Req_DEFAULT *pdpb.PutStoreRequest

func (p *PutStoreArgs) GetReq() *pdpb.PutStoreRequest {
	if !p.IsSetReq() {
		return PutStoreArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PutStoreArgs) IsSetReq() bool {
	return p.Req != nil
}

type PutStoreResult struct {
	Success *pdpb.PutStoreResponse
}

var PutStoreResult_Success_DEFAULT *pdpb.PutStoreResponse

func (p *PutStoreResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in PutStoreResult")
	}
	return proto.Marshal(p.Success)
}

func (p *PutStoreResult) Unmarshal(in []byte) error {
	msg := new(pdpb.PutStoreResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PutStoreResult) GetSuccess() *pdpb.PutStoreResponse {
	if !p.IsSetSuccess() {
		return PutStoreResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PutStoreResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.PutStoreResponse)
}

func (p *PutStoreResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getAllStoresHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetAllStoresRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetAllStores(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetAllStoresArgs:
		success, err := handler.(pdpb.PD).GetAllStores(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetAllStoresResult)
		realResult.Success = success
	}
	return nil
}
func newGetAllStoresArgs() interface{} {
	return &GetAllStoresArgs{}
}

func newGetAllStoresResult() interface{} {
	return &GetAllStoresResult{}
}

type GetAllStoresArgs struct {
	Req *pdpb.GetAllStoresRequest
}

func (p *GetAllStoresArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetAllStoresArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetAllStoresArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetAllStoresRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetAllStoresArgs_Req_DEFAULT *pdpb.GetAllStoresRequest

func (p *GetAllStoresArgs) GetReq() *pdpb.GetAllStoresRequest {
	if !p.IsSetReq() {
		return GetAllStoresArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetAllStoresArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetAllStoresResult struct {
	Success *pdpb.GetAllStoresResponse
}

var GetAllStoresResult_Success_DEFAULT *pdpb.GetAllStoresResponse

func (p *GetAllStoresResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetAllStoresResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetAllStoresResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetAllStoresResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetAllStoresResult) GetSuccess() *pdpb.GetAllStoresResponse {
	if !p.IsSetSuccess() {
		return GetAllStoresResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetAllStoresResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetAllStoresResponse)
}

func (p *GetAllStoresResult) IsSetSuccess() bool {
	return p.Success != nil
}

func storeHeartbeatHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.StoreHeartbeatRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).StoreHeartbeat(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *StoreHeartbeatArgs:
		success, err := handler.(pdpb.PD).StoreHeartbeat(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*StoreHeartbeatResult)
		realResult.Success = success
	}
	return nil
}
func newStoreHeartbeatArgs() interface{} {
	return &StoreHeartbeatArgs{}
}

func newStoreHeartbeatResult() interface{} {
	return &StoreHeartbeatResult{}
}

type StoreHeartbeatArgs struct {
	Req *pdpb.StoreHeartbeatRequest
}

func (p *StoreHeartbeatArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in StoreHeartbeatArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *StoreHeartbeatArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.StoreHeartbeatRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var StoreHeartbeatArgs_Req_DEFAULT *pdpb.StoreHeartbeatRequest

func (p *StoreHeartbeatArgs) GetReq() *pdpb.StoreHeartbeatRequest {
	if !p.IsSetReq() {
		return StoreHeartbeatArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *StoreHeartbeatArgs) IsSetReq() bool {
	return p.Req != nil
}

type StoreHeartbeatResult struct {
	Success *pdpb.StoreHeartbeatResponse
}

var StoreHeartbeatResult_Success_DEFAULT *pdpb.StoreHeartbeatResponse

func (p *StoreHeartbeatResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in StoreHeartbeatResult")
	}
	return proto.Marshal(p.Success)
}

func (p *StoreHeartbeatResult) Unmarshal(in []byte) error {
	msg := new(pdpb.StoreHeartbeatResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *StoreHeartbeatResult) GetSuccess() *pdpb.StoreHeartbeatResponse {
	if !p.IsSetSuccess() {
		return StoreHeartbeatResult_Success_DEFAULT
	}
	return p.Success
}

func (p *StoreHeartbeatResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.StoreHeartbeatResponse)
}

func (p *StoreHeartbeatResult) IsSetSuccess() bool {
	return p.Success != nil
}

func regionHeartbeatHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &pDRegionHeartbeatServer{st}
	return handler.(pdpb.PD).RegionHeartbeat(stream)
}

type pDRegionHeartbeatClient struct {
	streaming.Stream
}

func (x *pDRegionHeartbeatClient) Send(m *pdpb.RegionHeartbeatRequest) error {
	return x.Stream.SendMsg(m)
}
func (x *pDRegionHeartbeatClient) Recv() (*pdpb.RegionHeartbeatResponse, error) {
	m := new(pdpb.RegionHeartbeatResponse)
	return m, x.Stream.RecvMsg(m)
}

type pDRegionHeartbeatServer struct {
	streaming.Stream
}

func (x *pDRegionHeartbeatServer) Send(m *pdpb.RegionHeartbeatResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *pDRegionHeartbeatServer) Recv() (*pdpb.RegionHeartbeatRequest, error) {
	m := new(pdpb.RegionHeartbeatRequest)
	return m, x.Stream.RecvMsg(m)
}

func newRegionHeartbeatArgs() interface{} {
	return &RegionHeartbeatArgs{}
}

func newRegionHeartbeatResult() interface{} {
	return &RegionHeartbeatResult{}
}

type RegionHeartbeatArgs struct {
	Req *pdpb.RegionHeartbeatRequest
}

func (p *RegionHeartbeatArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RegionHeartbeatArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RegionHeartbeatArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.RegionHeartbeatRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RegionHeartbeatArgs_Req_DEFAULT *pdpb.RegionHeartbeatRequest

func (p *RegionHeartbeatArgs) GetReq() *pdpb.RegionHeartbeatRequest {
	if !p.IsSetReq() {
		return RegionHeartbeatArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RegionHeartbeatArgs) IsSetReq() bool {
	return p.Req != nil
}

type RegionHeartbeatResult struct {
	Success *pdpb.RegionHeartbeatResponse
}

var RegionHeartbeatResult_Success_DEFAULT *pdpb.RegionHeartbeatResponse

func (p *RegionHeartbeatResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RegionHeartbeatResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RegionHeartbeatResult) Unmarshal(in []byte) error {
	msg := new(pdpb.RegionHeartbeatResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RegionHeartbeatResult) GetSuccess() *pdpb.RegionHeartbeatResponse {
	if !p.IsSetSuccess() {
		return RegionHeartbeatResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RegionHeartbeatResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.RegionHeartbeatResponse)
}

func (p *RegionHeartbeatResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getRegionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetRegionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetRegion(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetRegionArgs:
		success, err := handler.(pdpb.PD).GetRegion(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetRegionResult)
		realResult.Success = success
	}
	return nil
}
func newGetRegionArgs() interface{} {
	return &GetRegionArgs{}
}

func newGetRegionResult() interface{} {
	return &GetRegionResult{}
}

type GetRegionArgs struct {
	Req *pdpb.GetRegionRequest
}

func (p *GetRegionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetRegionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetRegionArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetRegionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetRegionArgs_Req_DEFAULT *pdpb.GetRegionRequest

func (p *GetRegionArgs) GetReq() *pdpb.GetRegionRequest {
	if !p.IsSetReq() {
		return GetRegionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetRegionArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetRegionResult struct {
	Success *pdpb.GetRegionResponse
}

var GetRegionResult_Success_DEFAULT *pdpb.GetRegionResponse

func (p *GetRegionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetRegionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetRegionResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetRegionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetRegionResult) GetSuccess() *pdpb.GetRegionResponse {
	if !p.IsSetSuccess() {
		return GetRegionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetRegionResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetRegionResponse)
}

func (p *GetRegionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getPrevRegionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetRegionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetPrevRegion(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetPrevRegionArgs:
		success, err := handler.(pdpb.PD).GetPrevRegion(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetPrevRegionResult)
		realResult.Success = success
	}
	return nil
}
func newGetPrevRegionArgs() interface{} {
	return &GetPrevRegionArgs{}
}

func newGetPrevRegionResult() interface{} {
	return &GetPrevRegionResult{}
}

type GetPrevRegionArgs struct {
	Req *pdpb.GetRegionRequest
}

func (p *GetPrevRegionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetPrevRegionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetPrevRegionArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetRegionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetPrevRegionArgs_Req_DEFAULT *pdpb.GetRegionRequest

func (p *GetPrevRegionArgs) GetReq() *pdpb.GetRegionRequest {
	if !p.IsSetReq() {
		return GetPrevRegionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetPrevRegionArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetPrevRegionResult struct {
	Success *pdpb.GetRegionResponse
}

var GetPrevRegionResult_Success_DEFAULT *pdpb.GetRegionResponse

func (p *GetPrevRegionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetPrevRegionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetPrevRegionResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetRegionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetPrevRegionResult) GetSuccess() *pdpb.GetRegionResponse {
	if !p.IsSetSuccess() {
		return GetPrevRegionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetPrevRegionResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetRegionResponse)
}

func (p *GetPrevRegionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getRegionByIDHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetRegionByIDRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetRegionByID(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetRegionByIDArgs:
		success, err := handler.(pdpb.PD).GetRegionByID(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetRegionByIDResult)
		realResult.Success = success
	}
	return nil
}
func newGetRegionByIDArgs() interface{} {
	return &GetRegionByIDArgs{}
}

func newGetRegionByIDResult() interface{} {
	return &GetRegionByIDResult{}
}

type GetRegionByIDArgs struct {
	Req *pdpb.GetRegionByIDRequest
}

func (p *GetRegionByIDArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetRegionByIDArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetRegionByIDArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetRegionByIDRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetRegionByIDArgs_Req_DEFAULT *pdpb.GetRegionByIDRequest

func (p *GetRegionByIDArgs) GetReq() *pdpb.GetRegionByIDRequest {
	if !p.IsSetReq() {
		return GetRegionByIDArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetRegionByIDArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetRegionByIDResult struct {
	Success *pdpb.GetRegionResponse
}

var GetRegionByIDResult_Success_DEFAULT *pdpb.GetRegionResponse

func (p *GetRegionByIDResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetRegionByIDResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetRegionByIDResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetRegionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetRegionByIDResult) GetSuccess() *pdpb.GetRegionResponse {
	if !p.IsSetSuccess() {
		return GetRegionByIDResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetRegionByIDResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetRegionResponse)
}

func (p *GetRegionByIDResult) IsSetSuccess() bool {
	return p.Success != nil
}

func scanRegionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.ScanRegionsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).ScanRegions(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ScanRegionsArgs:
		success, err := handler.(pdpb.PD).ScanRegions(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ScanRegionsResult)
		realResult.Success = success
	}
	return nil
}
func newScanRegionsArgs() interface{} {
	return &ScanRegionsArgs{}
}

func newScanRegionsResult() interface{} {
	return &ScanRegionsResult{}
}

type ScanRegionsArgs struct {
	Req *pdpb.ScanRegionsRequest
}

func (p *ScanRegionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ScanRegionsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ScanRegionsArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.ScanRegionsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ScanRegionsArgs_Req_DEFAULT *pdpb.ScanRegionsRequest

func (p *ScanRegionsArgs) GetReq() *pdpb.ScanRegionsRequest {
	if !p.IsSetReq() {
		return ScanRegionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ScanRegionsArgs) IsSetReq() bool {
	return p.Req != nil
}

type ScanRegionsResult struct {
	Success *pdpb.ScanRegionsResponse
}

var ScanRegionsResult_Success_DEFAULT *pdpb.ScanRegionsResponse

func (p *ScanRegionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ScanRegionsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ScanRegionsResult) Unmarshal(in []byte) error {
	msg := new(pdpb.ScanRegionsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ScanRegionsResult) GetSuccess() *pdpb.ScanRegionsResponse {
	if !p.IsSetSuccess() {
		return ScanRegionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ScanRegionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.ScanRegionsResponse)
}

func (p *ScanRegionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func askSplitHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.AskSplitRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).AskSplit(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AskSplitArgs:
		success, err := handler.(pdpb.PD).AskSplit(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AskSplitResult)
		realResult.Success = success
	}
	return nil
}
func newAskSplitArgs() interface{} {
	return &AskSplitArgs{}
}

func newAskSplitResult() interface{} {
	return &AskSplitResult{}
}

type AskSplitArgs struct {
	Req *pdpb.AskSplitRequest
}

func (p *AskSplitArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in AskSplitArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *AskSplitArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.AskSplitRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AskSplitArgs_Req_DEFAULT *pdpb.AskSplitRequest

func (p *AskSplitArgs) GetReq() *pdpb.AskSplitRequest {
	if !p.IsSetReq() {
		return AskSplitArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AskSplitArgs) IsSetReq() bool {
	return p.Req != nil
}

type AskSplitResult struct {
	Success *pdpb.AskSplitResponse
}

var AskSplitResult_Success_DEFAULT *pdpb.AskSplitResponse

func (p *AskSplitResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in AskSplitResult")
	}
	return proto.Marshal(p.Success)
}

func (p *AskSplitResult) Unmarshal(in []byte) error {
	msg := new(pdpb.AskSplitResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AskSplitResult) GetSuccess() *pdpb.AskSplitResponse {
	if !p.IsSetSuccess() {
		return AskSplitResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AskSplitResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.AskSplitResponse)
}

func (p *AskSplitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func reportSplitHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.ReportSplitRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).ReportSplit(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ReportSplitArgs:
		success, err := handler.(pdpb.PD).ReportSplit(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ReportSplitResult)
		realResult.Success = success
	}
	return nil
}
func newReportSplitArgs() interface{} {
	return &ReportSplitArgs{}
}

func newReportSplitResult() interface{} {
	return &ReportSplitResult{}
}

type ReportSplitArgs struct {
	Req *pdpb.ReportSplitRequest
}

func (p *ReportSplitArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ReportSplitArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ReportSplitArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.ReportSplitRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ReportSplitArgs_Req_DEFAULT *pdpb.ReportSplitRequest

func (p *ReportSplitArgs) GetReq() *pdpb.ReportSplitRequest {
	if !p.IsSetReq() {
		return ReportSplitArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ReportSplitArgs) IsSetReq() bool {
	return p.Req != nil
}

type ReportSplitResult struct {
	Success *pdpb.ReportSplitResponse
}

var ReportSplitResult_Success_DEFAULT *pdpb.ReportSplitResponse

func (p *ReportSplitResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ReportSplitResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ReportSplitResult) Unmarshal(in []byte) error {
	msg := new(pdpb.ReportSplitResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ReportSplitResult) GetSuccess() *pdpb.ReportSplitResponse {
	if !p.IsSetSuccess() {
		return ReportSplitResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ReportSplitResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.ReportSplitResponse)
}

func (p *ReportSplitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func askBatchSplitHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.AskBatchSplitRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).AskBatchSplit(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AskBatchSplitArgs:
		success, err := handler.(pdpb.PD).AskBatchSplit(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AskBatchSplitResult)
		realResult.Success = success
	}
	return nil
}
func newAskBatchSplitArgs() interface{} {
	return &AskBatchSplitArgs{}
}

func newAskBatchSplitResult() interface{} {
	return &AskBatchSplitResult{}
}

type AskBatchSplitArgs struct {
	Req *pdpb.AskBatchSplitRequest
}

func (p *AskBatchSplitArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in AskBatchSplitArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *AskBatchSplitArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.AskBatchSplitRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AskBatchSplitArgs_Req_DEFAULT *pdpb.AskBatchSplitRequest

func (p *AskBatchSplitArgs) GetReq() *pdpb.AskBatchSplitRequest {
	if !p.IsSetReq() {
		return AskBatchSplitArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AskBatchSplitArgs) IsSetReq() bool {
	return p.Req != nil
}

type AskBatchSplitResult struct {
	Success *pdpb.AskBatchSplitResponse
}

var AskBatchSplitResult_Success_DEFAULT *pdpb.AskBatchSplitResponse

func (p *AskBatchSplitResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in AskBatchSplitResult")
	}
	return proto.Marshal(p.Success)
}

func (p *AskBatchSplitResult) Unmarshal(in []byte) error {
	msg := new(pdpb.AskBatchSplitResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AskBatchSplitResult) GetSuccess() *pdpb.AskBatchSplitResponse {
	if !p.IsSetSuccess() {
		return AskBatchSplitResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AskBatchSplitResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.AskBatchSplitResponse)
}

func (p *AskBatchSplitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func reportBatchSplitHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.ReportBatchSplitRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).ReportBatchSplit(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ReportBatchSplitArgs:
		success, err := handler.(pdpb.PD).ReportBatchSplit(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ReportBatchSplitResult)
		realResult.Success = success
	}
	return nil
}
func newReportBatchSplitArgs() interface{} {
	return &ReportBatchSplitArgs{}
}

func newReportBatchSplitResult() interface{} {
	return &ReportBatchSplitResult{}
}

type ReportBatchSplitArgs struct {
	Req *pdpb.ReportBatchSplitRequest
}

func (p *ReportBatchSplitArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ReportBatchSplitArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ReportBatchSplitArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.ReportBatchSplitRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ReportBatchSplitArgs_Req_DEFAULT *pdpb.ReportBatchSplitRequest

func (p *ReportBatchSplitArgs) GetReq() *pdpb.ReportBatchSplitRequest {
	if !p.IsSetReq() {
		return ReportBatchSplitArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ReportBatchSplitArgs) IsSetReq() bool {
	return p.Req != nil
}

type ReportBatchSplitResult struct {
	Success *pdpb.ReportBatchSplitResponse
}

var ReportBatchSplitResult_Success_DEFAULT *pdpb.ReportBatchSplitResponse

func (p *ReportBatchSplitResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ReportBatchSplitResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ReportBatchSplitResult) Unmarshal(in []byte) error {
	msg := new(pdpb.ReportBatchSplitResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ReportBatchSplitResult) GetSuccess() *pdpb.ReportBatchSplitResponse {
	if !p.IsSetSuccess() {
		return ReportBatchSplitResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ReportBatchSplitResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.ReportBatchSplitResponse)
}

func (p *ReportBatchSplitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getClusterConfigHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetClusterConfigRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetClusterConfig(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetClusterConfigArgs:
		success, err := handler.(pdpb.PD).GetClusterConfig(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetClusterConfigResult)
		realResult.Success = success
	}
	return nil
}
func newGetClusterConfigArgs() interface{} {
	return &GetClusterConfigArgs{}
}

func newGetClusterConfigResult() interface{} {
	return &GetClusterConfigResult{}
}

type GetClusterConfigArgs struct {
	Req *pdpb.GetClusterConfigRequest
}

func (p *GetClusterConfigArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetClusterConfigArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetClusterConfigArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetClusterConfigRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetClusterConfigArgs_Req_DEFAULT *pdpb.GetClusterConfigRequest

func (p *GetClusterConfigArgs) GetReq() *pdpb.GetClusterConfigRequest {
	if !p.IsSetReq() {
		return GetClusterConfigArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetClusterConfigArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetClusterConfigResult struct {
	Success *pdpb.GetClusterConfigResponse
}

var GetClusterConfigResult_Success_DEFAULT *pdpb.GetClusterConfigResponse

func (p *GetClusterConfigResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetClusterConfigResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetClusterConfigResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetClusterConfigResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetClusterConfigResult) GetSuccess() *pdpb.GetClusterConfigResponse {
	if !p.IsSetSuccess() {
		return GetClusterConfigResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetClusterConfigResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetClusterConfigResponse)
}

func (p *GetClusterConfigResult) IsSetSuccess() bool {
	return p.Success != nil
}

func putClusterConfigHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.PutClusterConfigRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).PutClusterConfig(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *PutClusterConfigArgs:
		success, err := handler.(pdpb.PD).PutClusterConfig(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PutClusterConfigResult)
		realResult.Success = success
	}
	return nil
}
func newPutClusterConfigArgs() interface{} {
	return &PutClusterConfigArgs{}
}

func newPutClusterConfigResult() interface{} {
	return &PutClusterConfigResult{}
}

type PutClusterConfigArgs struct {
	Req *pdpb.PutClusterConfigRequest
}

func (p *PutClusterConfigArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in PutClusterConfigArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *PutClusterConfigArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.PutClusterConfigRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PutClusterConfigArgs_Req_DEFAULT *pdpb.PutClusterConfigRequest

func (p *PutClusterConfigArgs) GetReq() *pdpb.PutClusterConfigRequest {
	if !p.IsSetReq() {
		return PutClusterConfigArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PutClusterConfigArgs) IsSetReq() bool {
	return p.Req != nil
}

type PutClusterConfigResult struct {
	Success *pdpb.PutClusterConfigResponse
}

var PutClusterConfigResult_Success_DEFAULT *pdpb.PutClusterConfigResponse

func (p *PutClusterConfigResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in PutClusterConfigResult")
	}
	return proto.Marshal(p.Success)
}

func (p *PutClusterConfigResult) Unmarshal(in []byte) error {
	msg := new(pdpb.PutClusterConfigResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PutClusterConfigResult) GetSuccess() *pdpb.PutClusterConfigResponse {
	if !p.IsSetSuccess() {
		return PutClusterConfigResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PutClusterConfigResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.PutClusterConfigResponse)
}

func (p *PutClusterConfigResult) IsSetSuccess() bool {
	return p.Success != nil
}

func scatterRegionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.ScatterRegionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).ScatterRegion(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ScatterRegionArgs:
		success, err := handler.(pdpb.PD).ScatterRegion(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ScatterRegionResult)
		realResult.Success = success
	}
	return nil
}
func newScatterRegionArgs() interface{} {
	return &ScatterRegionArgs{}
}

func newScatterRegionResult() interface{} {
	return &ScatterRegionResult{}
}

type ScatterRegionArgs struct {
	Req *pdpb.ScatterRegionRequest
}

func (p *ScatterRegionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ScatterRegionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ScatterRegionArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.ScatterRegionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ScatterRegionArgs_Req_DEFAULT *pdpb.ScatterRegionRequest

func (p *ScatterRegionArgs) GetReq() *pdpb.ScatterRegionRequest {
	if !p.IsSetReq() {
		return ScatterRegionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ScatterRegionArgs) IsSetReq() bool {
	return p.Req != nil
}

type ScatterRegionResult struct {
	Success *pdpb.ScatterRegionResponse
}

var ScatterRegionResult_Success_DEFAULT *pdpb.ScatterRegionResponse

func (p *ScatterRegionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ScatterRegionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ScatterRegionResult) Unmarshal(in []byte) error {
	msg := new(pdpb.ScatterRegionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ScatterRegionResult) GetSuccess() *pdpb.ScatterRegionResponse {
	if !p.IsSetSuccess() {
		return ScatterRegionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ScatterRegionResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.ScatterRegionResponse)
}

func (p *ScatterRegionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getGCSafePointHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetGCSafePointRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetGCSafePoint(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetGCSafePointArgs:
		success, err := handler.(pdpb.PD).GetGCSafePoint(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetGCSafePointResult)
		realResult.Success = success
	}
	return nil
}
func newGetGCSafePointArgs() interface{} {
	return &GetGCSafePointArgs{}
}

func newGetGCSafePointResult() interface{} {
	return &GetGCSafePointResult{}
}

type GetGCSafePointArgs struct {
	Req *pdpb.GetGCSafePointRequest
}

func (p *GetGCSafePointArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetGCSafePointArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetGCSafePointArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetGCSafePointRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetGCSafePointArgs_Req_DEFAULT *pdpb.GetGCSafePointRequest

func (p *GetGCSafePointArgs) GetReq() *pdpb.GetGCSafePointRequest {
	if !p.IsSetReq() {
		return GetGCSafePointArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetGCSafePointArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetGCSafePointResult struct {
	Success *pdpb.GetGCSafePointResponse
}

var GetGCSafePointResult_Success_DEFAULT *pdpb.GetGCSafePointResponse

func (p *GetGCSafePointResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetGCSafePointResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetGCSafePointResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetGCSafePointResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetGCSafePointResult) GetSuccess() *pdpb.GetGCSafePointResponse {
	if !p.IsSetSuccess() {
		return GetGCSafePointResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetGCSafePointResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetGCSafePointResponse)
}

func (p *GetGCSafePointResult) IsSetSuccess() bool {
	return p.Success != nil
}

func updateGCSafePointHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.UpdateGCSafePointRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).UpdateGCSafePoint(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdateGCSafePointArgs:
		success, err := handler.(pdpb.PD).UpdateGCSafePoint(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateGCSafePointResult)
		realResult.Success = success
	}
	return nil
}
func newUpdateGCSafePointArgs() interface{} {
	return &UpdateGCSafePointArgs{}
}

func newUpdateGCSafePointResult() interface{} {
	return &UpdateGCSafePointResult{}
}

type UpdateGCSafePointArgs struct {
	Req *pdpb.UpdateGCSafePointRequest
}

func (p *UpdateGCSafePointArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UpdateGCSafePointArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateGCSafePointArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.UpdateGCSafePointRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateGCSafePointArgs_Req_DEFAULT *pdpb.UpdateGCSafePointRequest

func (p *UpdateGCSafePointArgs) GetReq() *pdpb.UpdateGCSafePointRequest {
	if !p.IsSetReq() {
		return UpdateGCSafePointArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateGCSafePointArgs) IsSetReq() bool {
	return p.Req != nil
}

type UpdateGCSafePointResult struct {
	Success *pdpb.UpdateGCSafePointResponse
}

var UpdateGCSafePointResult_Success_DEFAULT *pdpb.UpdateGCSafePointResponse

func (p *UpdateGCSafePointResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UpdateGCSafePointResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateGCSafePointResult) Unmarshal(in []byte) error {
	msg := new(pdpb.UpdateGCSafePointResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateGCSafePointResult) GetSuccess() *pdpb.UpdateGCSafePointResponse {
	if !p.IsSetSuccess() {
		return UpdateGCSafePointResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateGCSafePointResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.UpdateGCSafePointResponse)
}

func (p *UpdateGCSafePointResult) IsSetSuccess() bool {
	return p.Success != nil
}

func updateServiceGCSafePointHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.UpdateServiceGCSafePointRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).UpdateServiceGCSafePoint(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *UpdateServiceGCSafePointArgs:
		success, err := handler.(pdpb.PD).UpdateServiceGCSafePoint(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*UpdateServiceGCSafePointResult)
		realResult.Success = success
	}
	return nil
}
func newUpdateServiceGCSafePointArgs() interface{} {
	return &UpdateServiceGCSafePointArgs{}
}

func newUpdateServiceGCSafePointResult() interface{} {
	return &UpdateServiceGCSafePointResult{}
}

type UpdateServiceGCSafePointArgs struct {
	Req *pdpb.UpdateServiceGCSafePointRequest
}

func (p *UpdateServiceGCSafePointArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UpdateServiceGCSafePointArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UpdateServiceGCSafePointArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.UpdateServiceGCSafePointRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UpdateServiceGCSafePointArgs_Req_DEFAULT *pdpb.UpdateServiceGCSafePointRequest

func (p *UpdateServiceGCSafePointArgs) GetReq() *pdpb.UpdateServiceGCSafePointRequest {
	if !p.IsSetReq() {
		return UpdateServiceGCSafePointArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UpdateServiceGCSafePointArgs) IsSetReq() bool {
	return p.Req != nil
}

type UpdateServiceGCSafePointResult struct {
	Success *pdpb.UpdateServiceGCSafePointResponse
}

var UpdateServiceGCSafePointResult_Success_DEFAULT *pdpb.UpdateServiceGCSafePointResponse

func (p *UpdateServiceGCSafePointResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UpdateServiceGCSafePointResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UpdateServiceGCSafePointResult) Unmarshal(in []byte) error {
	msg := new(pdpb.UpdateServiceGCSafePointResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UpdateServiceGCSafePointResult) GetSuccess() *pdpb.UpdateServiceGCSafePointResponse {
	if !p.IsSetSuccess() {
		return UpdateServiceGCSafePointResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UpdateServiceGCSafePointResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.UpdateServiceGCSafePointResponse)
}

func (p *UpdateServiceGCSafePointResult) IsSetSuccess() bool {
	return p.Success != nil
}

func syncRegionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &pDSyncRegionsServer{st}
	return handler.(pdpb.PD).SyncRegions(stream)
}

type pDSyncRegionsClient struct {
	streaming.Stream
}

func (x *pDSyncRegionsClient) Send(m *pdpb.SyncRegionRequest) error {
	return x.Stream.SendMsg(m)
}
func (x *pDSyncRegionsClient) Recv() (*pdpb.SyncRegionResponse, error) {
	m := new(pdpb.SyncRegionResponse)
	return m, x.Stream.RecvMsg(m)
}

type pDSyncRegionsServer struct {
	streaming.Stream
}

func (x *pDSyncRegionsServer) Send(m *pdpb.SyncRegionResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *pDSyncRegionsServer) Recv() (*pdpb.SyncRegionRequest, error) {
	m := new(pdpb.SyncRegionRequest)
	return m, x.Stream.RecvMsg(m)
}

func newSyncRegionsArgs() interface{} {
	return &SyncRegionsArgs{}
}

func newSyncRegionsResult() interface{} {
	return &SyncRegionsResult{}
}

type SyncRegionsArgs struct {
	Req *pdpb.SyncRegionRequest
}

func (p *SyncRegionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SyncRegionsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SyncRegionsArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.SyncRegionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SyncRegionsArgs_Req_DEFAULT *pdpb.SyncRegionRequest

func (p *SyncRegionsArgs) GetReq() *pdpb.SyncRegionRequest {
	if !p.IsSetReq() {
		return SyncRegionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SyncRegionsArgs) IsSetReq() bool {
	return p.Req != nil
}

type SyncRegionsResult struct {
	Success *pdpb.SyncRegionResponse
}

var SyncRegionsResult_Success_DEFAULT *pdpb.SyncRegionResponse

func (p *SyncRegionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SyncRegionsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SyncRegionsResult) Unmarshal(in []byte) error {
	msg := new(pdpb.SyncRegionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SyncRegionsResult) GetSuccess() *pdpb.SyncRegionResponse {
	if !p.IsSetSuccess() {
		return SyncRegionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SyncRegionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.SyncRegionResponse)
}

func (p *SyncRegionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getOperatorHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetOperatorRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetOperator(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetOperatorArgs:
		success, err := handler.(pdpb.PD).GetOperator(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetOperatorResult)
		realResult.Success = success
	}
	return nil
}
func newGetOperatorArgs() interface{} {
	return &GetOperatorArgs{}
}

func newGetOperatorResult() interface{} {
	return &GetOperatorResult{}
}

type GetOperatorArgs struct {
	Req *pdpb.GetOperatorRequest
}

func (p *GetOperatorArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetOperatorArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetOperatorArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetOperatorRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetOperatorArgs_Req_DEFAULT *pdpb.GetOperatorRequest

func (p *GetOperatorArgs) GetReq() *pdpb.GetOperatorRequest {
	if !p.IsSetReq() {
		return GetOperatorArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetOperatorArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetOperatorResult struct {
	Success *pdpb.GetOperatorResponse
}

var GetOperatorResult_Success_DEFAULT *pdpb.GetOperatorResponse

func (p *GetOperatorResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetOperatorResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetOperatorResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetOperatorResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetOperatorResult) GetSuccess() *pdpb.GetOperatorResponse {
	if !p.IsSetSuccess() {
		return GetOperatorResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetOperatorResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetOperatorResponse)
}

func (p *GetOperatorResult) IsSetSuccess() bool {
	return p.Success != nil
}

func syncMaxTSHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.SyncMaxTSRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).SyncMaxTS(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SyncMaxTSArgs:
		success, err := handler.(pdpb.PD).SyncMaxTS(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SyncMaxTSResult)
		realResult.Success = success
	}
	return nil
}
func newSyncMaxTSArgs() interface{} {
	return &SyncMaxTSArgs{}
}

func newSyncMaxTSResult() interface{} {
	return &SyncMaxTSResult{}
}

type SyncMaxTSArgs struct {
	Req *pdpb.SyncMaxTSRequest
}

func (p *SyncMaxTSArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SyncMaxTSArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SyncMaxTSArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.SyncMaxTSRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SyncMaxTSArgs_Req_DEFAULT *pdpb.SyncMaxTSRequest

func (p *SyncMaxTSArgs) GetReq() *pdpb.SyncMaxTSRequest {
	if !p.IsSetReq() {
		return SyncMaxTSArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SyncMaxTSArgs) IsSetReq() bool {
	return p.Req != nil
}

type SyncMaxTSResult struct {
	Success *pdpb.SyncMaxTSResponse
}

var SyncMaxTSResult_Success_DEFAULT *pdpb.SyncMaxTSResponse

func (p *SyncMaxTSResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SyncMaxTSResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SyncMaxTSResult) Unmarshal(in []byte) error {
	msg := new(pdpb.SyncMaxTSResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SyncMaxTSResult) GetSuccess() *pdpb.SyncMaxTSResponse {
	if !p.IsSetSuccess() {
		return SyncMaxTSResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SyncMaxTSResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.SyncMaxTSResponse)
}

func (p *SyncMaxTSResult) IsSetSuccess() bool {
	return p.Success != nil
}

func splitRegionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.SplitRegionsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).SplitRegions(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SplitRegionsArgs:
		success, err := handler.(pdpb.PD).SplitRegions(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SplitRegionsResult)
		realResult.Success = success
	}
	return nil
}
func newSplitRegionsArgs() interface{} {
	return &SplitRegionsArgs{}
}

func newSplitRegionsResult() interface{} {
	return &SplitRegionsResult{}
}

type SplitRegionsArgs struct {
	Req *pdpb.SplitRegionsRequest
}

func (p *SplitRegionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SplitRegionsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SplitRegionsArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.SplitRegionsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SplitRegionsArgs_Req_DEFAULT *pdpb.SplitRegionsRequest

func (p *SplitRegionsArgs) GetReq() *pdpb.SplitRegionsRequest {
	if !p.IsSetReq() {
		return SplitRegionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SplitRegionsArgs) IsSetReq() bool {
	return p.Req != nil
}

type SplitRegionsResult struct {
	Success *pdpb.SplitRegionsResponse
}

var SplitRegionsResult_Success_DEFAULT *pdpb.SplitRegionsResponse

func (p *SplitRegionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SplitRegionsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SplitRegionsResult) Unmarshal(in []byte) error {
	msg := new(pdpb.SplitRegionsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SplitRegionsResult) GetSuccess() *pdpb.SplitRegionsResponse {
	if !p.IsSetSuccess() {
		return SplitRegionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SplitRegionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.SplitRegionsResponse)
}

func (p *SplitRegionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func splitAndScatterRegionsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.SplitAndScatterRegionsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).SplitAndScatterRegions(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SplitAndScatterRegionsArgs:
		success, err := handler.(pdpb.PD).SplitAndScatterRegions(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SplitAndScatterRegionsResult)
		realResult.Success = success
	}
	return nil
}
func newSplitAndScatterRegionsArgs() interface{} {
	return &SplitAndScatterRegionsArgs{}
}

func newSplitAndScatterRegionsResult() interface{} {
	return &SplitAndScatterRegionsResult{}
}

type SplitAndScatterRegionsArgs struct {
	Req *pdpb.SplitAndScatterRegionsRequest
}

func (p *SplitAndScatterRegionsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SplitAndScatterRegionsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SplitAndScatterRegionsArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.SplitAndScatterRegionsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SplitAndScatterRegionsArgs_Req_DEFAULT *pdpb.SplitAndScatterRegionsRequest

func (p *SplitAndScatterRegionsArgs) GetReq() *pdpb.SplitAndScatterRegionsRequest {
	if !p.IsSetReq() {
		return SplitAndScatterRegionsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SplitAndScatterRegionsArgs) IsSetReq() bool {
	return p.Req != nil
}

type SplitAndScatterRegionsResult struct {
	Success *pdpb.SplitAndScatterRegionsResponse
}

var SplitAndScatterRegionsResult_Success_DEFAULT *pdpb.SplitAndScatterRegionsResponse

func (p *SplitAndScatterRegionsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SplitAndScatterRegionsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SplitAndScatterRegionsResult) Unmarshal(in []byte) error {
	msg := new(pdpb.SplitAndScatterRegionsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SplitAndScatterRegionsResult) GetSuccess() *pdpb.SplitAndScatterRegionsResponse {
	if !p.IsSetSuccess() {
		return SplitAndScatterRegionsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SplitAndScatterRegionsResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.SplitAndScatterRegionsResponse)
}

func (p *SplitAndScatterRegionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getDCLocationInfoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(pdpb.GetDCLocationInfoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(pdpb.PD).GetDCLocationInfo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetDCLocationInfoArgs:
		success, err := handler.(pdpb.PD).GetDCLocationInfo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetDCLocationInfoResult)
		realResult.Success = success
	}
	return nil
}
func newGetDCLocationInfoArgs() interface{} {
	return &GetDCLocationInfoArgs{}
}

func newGetDCLocationInfoResult() interface{} {
	return &GetDCLocationInfoResult{}
}

type GetDCLocationInfoArgs struct {
	Req *pdpb.GetDCLocationInfoRequest
}

func (p *GetDCLocationInfoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetDCLocationInfoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetDCLocationInfoArgs) Unmarshal(in []byte) error {
	msg := new(pdpb.GetDCLocationInfoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetDCLocationInfoArgs_Req_DEFAULT *pdpb.GetDCLocationInfoRequest

func (p *GetDCLocationInfoArgs) GetReq() *pdpb.GetDCLocationInfoRequest {
	if !p.IsSetReq() {
		return GetDCLocationInfoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetDCLocationInfoArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetDCLocationInfoResult struct {
	Success *pdpb.GetDCLocationInfoResponse
}

var GetDCLocationInfoResult_Success_DEFAULT *pdpb.GetDCLocationInfoResponse

func (p *GetDCLocationInfoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetDCLocationInfoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetDCLocationInfoResult) Unmarshal(in []byte) error {
	msg := new(pdpb.GetDCLocationInfoResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetDCLocationInfoResult) GetSuccess() *pdpb.GetDCLocationInfoResponse {
	if !p.IsSetSuccess() {
		return GetDCLocationInfoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetDCLocationInfoResult) SetSuccess(x interface{}) {
	p.Success = x.(*pdpb.GetDCLocationInfoResponse)
}

func (p *GetDCLocationInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) GetMembers(ctx context.Context, Req *pdpb.GetMembersRequest) (r *pdpb.GetMembersResponse, err error) {
	var _args GetMembersArgs
	_args.Req = Req
	var _result GetMembersResult
	if err = p.c.Call(ctx, "GetMembers", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Tso(ctx context.Context) (PD_TsoClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "Tso", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &pDTsoClient{res.Stream}
	return stream, nil
}

func (p *kClient) Bootstrap(ctx context.Context, Req *pdpb.BootstrapRequest) (r *pdpb.BootstrapResponse, err error) {
	var _args BootstrapArgs
	_args.Req = Req
	var _result BootstrapResult
	if err = p.c.Call(ctx, "Bootstrap", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) IsBootstrapped(ctx context.Context, Req *pdpb.IsBootstrappedRequest) (r *pdpb.IsBootstrappedResponse, err error) {
	var _args IsBootstrappedArgs
	_args.Req = Req
	var _result IsBootstrappedResult
	if err = p.c.Call(ctx, "IsBootstrapped", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AllocID(ctx context.Context, Req *pdpb.AllocIDRequest) (r *pdpb.AllocIDResponse, err error) {
	var _args AllocIDArgs
	_args.Req = Req
	var _result AllocIDResult
	if err = p.c.Call(ctx, "AllocID", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetStore(ctx context.Context, Req *pdpb.GetStoreRequest) (r *pdpb.GetStoreResponse, err error) {
	var _args GetStoreArgs
	_args.Req = Req
	var _result GetStoreResult
	if err = p.c.Call(ctx, "GetStore", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PutStore(ctx context.Context, Req *pdpb.PutStoreRequest) (r *pdpb.PutStoreResponse, err error) {
	var _args PutStoreArgs
	_args.Req = Req
	var _result PutStoreResult
	if err = p.c.Call(ctx, "PutStore", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetAllStores(ctx context.Context, Req *pdpb.GetAllStoresRequest) (r *pdpb.GetAllStoresResponse, err error) {
	var _args GetAllStoresArgs
	_args.Req = Req
	var _result GetAllStoresResult
	if err = p.c.Call(ctx, "GetAllStores", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) StoreHeartbeat(ctx context.Context, Req *pdpb.StoreHeartbeatRequest) (r *pdpb.StoreHeartbeatResponse, err error) {
	var _args StoreHeartbeatArgs
	_args.Req = Req
	var _result StoreHeartbeatResult
	if err = p.c.Call(ctx, "StoreHeartbeat", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RegionHeartbeat(ctx context.Context) (PD_RegionHeartbeatClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "RegionHeartbeat", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &pDRegionHeartbeatClient{res.Stream}
	return stream, nil
}

func (p *kClient) GetRegion(ctx context.Context, Req *pdpb.GetRegionRequest) (r *pdpb.GetRegionResponse, err error) {
	var _args GetRegionArgs
	_args.Req = Req
	var _result GetRegionResult
	if err = p.c.Call(ctx, "GetRegion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetPrevRegion(ctx context.Context, Req *pdpb.GetRegionRequest) (r *pdpb.GetRegionResponse, err error) {
	var _args GetPrevRegionArgs
	_args.Req = Req
	var _result GetPrevRegionResult
	if err = p.c.Call(ctx, "GetPrevRegion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetRegionByID(ctx context.Context, Req *pdpb.GetRegionByIDRequest) (r *pdpb.GetRegionResponse, err error) {
	var _args GetRegionByIDArgs
	_args.Req = Req
	var _result GetRegionByIDResult
	if err = p.c.Call(ctx, "GetRegionByID", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ScanRegions(ctx context.Context, Req *pdpb.ScanRegionsRequest) (r *pdpb.ScanRegionsResponse, err error) {
	var _args ScanRegionsArgs
	_args.Req = Req
	var _result ScanRegionsResult
	if err = p.c.Call(ctx, "ScanRegions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AskSplit(ctx context.Context, Req *pdpb.AskSplitRequest) (r *pdpb.AskSplitResponse, err error) {
	var _args AskSplitArgs
	_args.Req = Req
	var _result AskSplitResult
	if err = p.c.Call(ctx, "AskSplit", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ReportSplit(ctx context.Context, Req *pdpb.ReportSplitRequest) (r *pdpb.ReportSplitResponse, err error) {
	var _args ReportSplitArgs
	_args.Req = Req
	var _result ReportSplitResult
	if err = p.c.Call(ctx, "ReportSplit", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AskBatchSplit(ctx context.Context, Req *pdpb.AskBatchSplitRequest) (r *pdpb.AskBatchSplitResponse, err error) {
	var _args AskBatchSplitArgs
	_args.Req = Req
	var _result AskBatchSplitResult
	if err = p.c.Call(ctx, "AskBatchSplit", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ReportBatchSplit(ctx context.Context, Req *pdpb.ReportBatchSplitRequest) (r *pdpb.ReportBatchSplitResponse, err error) {
	var _args ReportBatchSplitArgs
	_args.Req = Req
	var _result ReportBatchSplitResult
	if err = p.c.Call(ctx, "ReportBatchSplit", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetClusterConfig(ctx context.Context, Req *pdpb.GetClusterConfigRequest) (r *pdpb.GetClusterConfigResponse, err error) {
	var _args GetClusterConfigArgs
	_args.Req = Req
	var _result GetClusterConfigResult
	if err = p.c.Call(ctx, "GetClusterConfig", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) PutClusterConfig(ctx context.Context, Req *pdpb.PutClusterConfigRequest) (r *pdpb.PutClusterConfigResponse, err error) {
	var _args PutClusterConfigArgs
	_args.Req = Req
	var _result PutClusterConfigResult
	if err = p.c.Call(ctx, "PutClusterConfig", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ScatterRegion(ctx context.Context, Req *pdpb.ScatterRegionRequest) (r *pdpb.ScatterRegionResponse, err error) {
	var _args ScatterRegionArgs
	_args.Req = Req
	var _result ScatterRegionResult
	if err = p.c.Call(ctx, "ScatterRegion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetGCSafePoint(ctx context.Context, Req *pdpb.GetGCSafePointRequest) (r *pdpb.GetGCSafePointResponse, err error) {
	var _args GetGCSafePointArgs
	_args.Req = Req
	var _result GetGCSafePointResult
	if err = p.c.Call(ctx, "GetGCSafePoint", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateGCSafePoint(ctx context.Context, Req *pdpb.UpdateGCSafePointRequest) (r *pdpb.UpdateGCSafePointResponse, err error) {
	var _args UpdateGCSafePointArgs
	_args.Req = Req
	var _result UpdateGCSafePointResult
	if err = p.c.Call(ctx, "UpdateGCSafePoint", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) UpdateServiceGCSafePoint(ctx context.Context, Req *pdpb.UpdateServiceGCSafePointRequest) (r *pdpb.UpdateServiceGCSafePointResponse, err error) {
	var _args UpdateServiceGCSafePointArgs
	_args.Req = Req
	var _result UpdateServiceGCSafePointResult
	if err = p.c.Call(ctx, "UpdateServiceGCSafePoint", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SyncRegions(ctx context.Context) (PD_SyncRegionsClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "SyncRegions", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &pDSyncRegionsClient{res.Stream}
	return stream, nil
}

func (p *kClient) GetOperator(ctx context.Context, Req *pdpb.GetOperatorRequest) (r *pdpb.GetOperatorResponse, err error) {
	var _args GetOperatorArgs
	_args.Req = Req
	var _result GetOperatorResult
	if err = p.c.Call(ctx, "GetOperator", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SyncMaxTS(ctx context.Context, Req *pdpb.SyncMaxTSRequest) (r *pdpb.SyncMaxTSResponse, err error) {
	var _args SyncMaxTSArgs
	_args.Req = Req
	var _result SyncMaxTSResult
	if err = p.c.Call(ctx, "SyncMaxTS", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SplitRegions(ctx context.Context, Req *pdpb.SplitRegionsRequest) (r *pdpb.SplitRegionsResponse, err error) {
	var _args SplitRegionsArgs
	_args.Req = Req
	var _result SplitRegionsResult
	if err = p.c.Call(ctx, "SplitRegions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SplitAndScatterRegions(ctx context.Context, Req *pdpb.SplitAndScatterRegionsRequest) (r *pdpb.SplitAndScatterRegionsResponse, err error) {
	var _args SplitAndScatterRegionsArgs
	_args.Req = Req
	var _result SplitAndScatterRegionsResult
	if err = p.c.Call(ctx, "SplitAndScatterRegions", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetDCLocationInfo(ctx context.Context, Req *pdpb.GetDCLocationInfoRequest) (r *pdpb.GetDCLocationInfoResponse, err error) {
	var _args GetDCLocationInfoArgs
	_args.Req = Req
	var _result GetDCLocationInfoResult
	if err = p.c.Call(ctx, "GetDCLocationInfo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
