// Code generated by Kitex v0.1.3. DO NOT EDIT.

package importsst

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/pingcap/kvproto/proto/kitex_gen/import_sstpb"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return importSSTServiceInfo
}

var importSSTServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "ImportSST"
	handlerType := (*import_sstpb.ImportSST)(nil)
	methods := map[string]kitex.MethodInfo{
		"SwitchMode":            kitex.NewMethodInfo(switchModeHandler, newSwitchModeArgs, newSwitchModeResult, false),
		"Upload":                kitex.NewMethodInfo(uploadHandler, newUploadArgs, newUploadResult, false),
		"Ingest":                kitex.NewMethodInfo(ingestHandler, newIngestArgs, newIngestResult, false),
		"Compact":               kitex.NewMethodInfo(compactHandler, newCompactArgs, newCompactResult, false),
		"SetDownloadSpeedLimit": kitex.NewMethodInfo(setDownloadSpeedLimitHandler, newSetDownloadSpeedLimitArgs, newSetDownloadSpeedLimitResult, false),
		"Download":              kitex.NewMethodInfo(downloadHandler, newDownloadArgs, newDownloadResult, false),
		"Write":                 kitex.NewMethodInfo(writeHandler, newWriteArgs, newWriteResult, false),
		"RawWrite":              kitex.NewMethodInfo(rawWriteHandler, newRawWriteArgs, newRawWriteResult, false),
		"MultiIngest":           kitex.NewMethodInfo(multiIngestHandler, newMultiIngestArgs, newMultiIngestResult, false),
		"DuplicateDetect":       kitex.NewMethodInfo(duplicateDetectHandler, newDuplicateDetectArgs, newDuplicateDetectResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "import_sstpb",
	}
	extra["streaming"] = true
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.1.3",
		Extra:           extra,
	}
	return svcInfo
}

func switchModeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_sstpb.SwitchModeRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_sstpb.ImportSST).SwitchMode(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SwitchModeArgs:
		success, err := handler.(import_sstpb.ImportSST).SwitchMode(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SwitchModeResult)
		realResult.Success = success
	}
	return nil
}
func newSwitchModeArgs() interface{} {
	return &SwitchModeArgs{}
}

func newSwitchModeResult() interface{} {
	return &SwitchModeResult{}
}

type SwitchModeArgs struct {
	Req *import_sstpb.SwitchModeRequest
}

func (p *SwitchModeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SwitchModeArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SwitchModeArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.SwitchModeRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SwitchModeArgs_Req_DEFAULT *import_sstpb.SwitchModeRequest

func (p *SwitchModeArgs) GetReq() *import_sstpb.SwitchModeRequest {
	if !p.IsSetReq() {
		return SwitchModeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SwitchModeArgs) IsSetReq() bool {
	return p.Req != nil
}

type SwitchModeResult struct {
	Success *import_sstpb.SwitchModeResponse
}

var SwitchModeResult_Success_DEFAULT *import_sstpb.SwitchModeResponse

func (p *SwitchModeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SwitchModeResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SwitchModeResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.SwitchModeResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SwitchModeResult) GetSuccess() *import_sstpb.SwitchModeResponse {
	if !p.IsSetSuccess() {
		return SwitchModeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SwitchModeResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.SwitchModeResponse)
}

func (p *SwitchModeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func uploadHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &importSSTUploadServer{st}
	return handler.(import_sstpb.ImportSST).Upload(stream)
}

type importSSTUploadClient struct {
	streaming.Stream
}

func (x *importSSTUploadClient) Send(m *import_sstpb.UploadRequest) error {
	return x.Stream.SendMsg(m)
}
func (x *importSSTUploadClient) CloseAndRecv() (*import_sstpb.UploadResponse, error) {
	if err := x.Stream.Close(); err != nil {
		return nil, err
	}
	m := new(import_sstpb.UploadResponse)
	return m, x.Stream.RecvMsg(m)
}

type importSSTUploadServer struct {
	streaming.Stream
}

func (x *importSSTUploadServer) SendAndClose(m *import_sstpb.UploadResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *importSSTUploadServer) Recv() (*import_sstpb.UploadRequest, error) {
	m := new(import_sstpb.UploadRequest)
	return m, x.Stream.RecvMsg(m)
}

func newUploadArgs() interface{} {
	return &UploadArgs{}
}

func newUploadResult() interface{} {
	return &UploadResult{}
}

type UploadArgs struct {
	Req *import_sstpb.UploadRequest
}

func (p *UploadArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in UploadArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *UploadArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.UploadRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var UploadArgs_Req_DEFAULT *import_sstpb.UploadRequest

func (p *UploadArgs) GetReq() *import_sstpb.UploadRequest {
	if !p.IsSetReq() {
		return UploadArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *UploadArgs) IsSetReq() bool {
	return p.Req != nil
}

type UploadResult struct {
	Success *import_sstpb.UploadResponse
}

var UploadResult_Success_DEFAULT *import_sstpb.UploadResponse

func (p *UploadResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in UploadResult")
	}
	return proto.Marshal(p.Success)
}

func (p *UploadResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.UploadResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *UploadResult) GetSuccess() *import_sstpb.UploadResponse {
	if !p.IsSetSuccess() {
		return UploadResult_Success_DEFAULT
	}
	return p.Success
}

func (p *UploadResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.UploadResponse)
}

func (p *UploadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func ingestHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_sstpb.IngestRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_sstpb.ImportSST).Ingest(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *IngestArgs:
		success, err := handler.(import_sstpb.ImportSST).Ingest(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*IngestResult)
		realResult.Success = success
	}
	return nil
}
func newIngestArgs() interface{} {
	return &IngestArgs{}
}

func newIngestResult() interface{} {
	return &IngestResult{}
}

type IngestArgs struct {
	Req *import_sstpb.IngestRequest
}

func (p *IngestArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in IngestArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *IngestArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.IngestRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var IngestArgs_Req_DEFAULT *import_sstpb.IngestRequest

func (p *IngestArgs) GetReq() *import_sstpb.IngestRequest {
	if !p.IsSetReq() {
		return IngestArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *IngestArgs) IsSetReq() bool {
	return p.Req != nil
}

type IngestResult struct {
	Success *import_sstpb.IngestResponse
}

var IngestResult_Success_DEFAULT *import_sstpb.IngestResponse

func (p *IngestResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in IngestResult")
	}
	return proto.Marshal(p.Success)
}

func (p *IngestResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.IngestResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *IngestResult) GetSuccess() *import_sstpb.IngestResponse {
	if !p.IsSetSuccess() {
		return IngestResult_Success_DEFAULT
	}
	return p.Success
}

func (p *IngestResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.IngestResponse)
}

func (p *IngestResult) IsSetSuccess() bool {
	return p.Success != nil
}

func compactHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_sstpb.CompactRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_sstpb.ImportSST).Compact(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CompactArgs:
		success, err := handler.(import_sstpb.ImportSST).Compact(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompactResult)
		realResult.Success = success
	}
	return nil
}
func newCompactArgs() interface{} {
	return &CompactArgs{}
}

func newCompactResult() interface{} {
	return &CompactResult{}
}

type CompactArgs struct {
	Req *import_sstpb.CompactRequest
}

func (p *CompactArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CompactArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CompactArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.CompactRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompactArgs_Req_DEFAULT *import_sstpb.CompactRequest

func (p *CompactArgs) GetReq() *import_sstpb.CompactRequest {
	if !p.IsSetReq() {
		return CompactArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompactArgs) IsSetReq() bool {
	return p.Req != nil
}

type CompactResult struct {
	Success *import_sstpb.CompactResponse
}

var CompactResult_Success_DEFAULT *import_sstpb.CompactResponse

func (p *CompactResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CompactResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CompactResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.CompactResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompactResult) GetSuccess() *import_sstpb.CompactResponse {
	if !p.IsSetSuccess() {
		return CompactResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompactResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.CompactResponse)
}

func (p *CompactResult) IsSetSuccess() bool {
	return p.Success != nil
}

func setDownloadSpeedLimitHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_sstpb.SetDownloadSpeedLimitRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_sstpb.ImportSST).SetDownloadSpeedLimit(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SetDownloadSpeedLimitArgs:
		success, err := handler.(import_sstpb.ImportSST).SetDownloadSpeedLimit(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SetDownloadSpeedLimitResult)
		realResult.Success = success
	}
	return nil
}
func newSetDownloadSpeedLimitArgs() interface{} {
	return &SetDownloadSpeedLimitArgs{}
}

func newSetDownloadSpeedLimitResult() interface{} {
	return &SetDownloadSpeedLimitResult{}
}

type SetDownloadSpeedLimitArgs struct {
	Req *import_sstpb.SetDownloadSpeedLimitRequest
}

func (p *SetDownloadSpeedLimitArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SetDownloadSpeedLimitArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SetDownloadSpeedLimitArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.SetDownloadSpeedLimitRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SetDownloadSpeedLimitArgs_Req_DEFAULT *import_sstpb.SetDownloadSpeedLimitRequest

func (p *SetDownloadSpeedLimitArgs) GetReq() *import_sstpb.SetDownloadSpeedLimitRequest {
	if !p.IsSetReq() {
		return SetDownloadSpeedLimitArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SetDownloadSpeedLimitArgs) IsSetReq() bool {
	return p.Req != nil
}

type SetDownloadSpeedLimitResult struct {
	Success *import_sstpb.SetDownloadSpeedLimitResponse
}

var SetDownloadSpeedLimitResult_Success_DEFAULT *import_sstpb.SetDownloadSpeedLimitResponse

func (p *SetDownloadSpeedLimitResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SetDownloadSpeedLimitResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SetDownloadSpeedLimitResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.SetDownloadSpeedLimitResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SetDownloadSpeedLimitResult) GetSuccess() *import_sstpb.SetDownloadSpeedLimitResponse {
	if !p.IsSetSuccess() {
		return SetDownloadSpeedLimitResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SetDownloadSpeedLimitResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.SetDownloadSpeedLimitResponse)
}

func (p *SetDownloadSpeedLimitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func downloadHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_sstpb.DownloadRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_sstpb.ImportSST).Download(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DownloadArgs:
		success, err := handler.(import_sstpb.ImportSST).Download(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DownloadResult)
		realResult.Success = success
	}
	return nil
}
func newDownloadArgs() interface{} {
	return &DownloadArgs{}
}

func newDownloadResult() interface{} {
	return &DownloadResult{}
}

type DownloadArgs struct {
	Req *import_sstpb.DownloadRequest
}

func (p *DownloadArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DownloadArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DownloadArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.DownloadRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DownloadArgs_Req_DEFAULT *import_sstpb.DownloadRequest

func (p *DownloadArgs) GetReq() *import_sstpb.DownloadRequest {
	if !p.IsSetReq() {
		return DownloadArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DownloadArgs) IsSetReq() bool {
	return p.Req != nil
}

type DownloadResult struct {
	Success *import_sstpb.DownloadResponse
}

var DownloadResult_Success_DEFAULT *import_sstpb.DownloadResponse

func (p *DownloadResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DownloadResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DownloadResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.DownloadResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DownloadResult) GetSuccess() *import_sstpb.DownloadResponse {
	if !p.IsSetSuccess() {
		return DownloadResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DownloadResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.DownloadResponse)
}

func (p *DownloadResult) IsSetSuccess() bool {
	return p.Success != nil
}

func writeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &importSSTWriteServer{st}
	return handler.(import_sstpb.ImportSST).Write(stream)
}

type importSSTWriteClient struct {
	streaming.Stream
}

func (x *importSSTWriteClient) Send(m *import_sstpb.WriteRequest) error {
	return x.Stream.SendMsg(m)
}
func (x *importSSTWriteClient) CloseAndRecv() (*import_sstpb.WriteResponse, error) {
	if err := x.Stream.Close(); err != nil {
		return nil, err
	}
	m := new(import_sstpb.WriteResponse)
	return m, x.Stream.RecvMsg(m)
}

type importSSTWriteServer struct {
	streaming.Stream
}

func (x *importSSTWriteServer) SendAndClose(m *import_sstpb.WriteResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *importSSTWriteServer) Recv() (*import_sstpb.WriteRequest, error) {
	m := new(import_sstpb.WriteRequest)
	return m, x.Stream.RecvMsg(m)
}

func newWriteArgs() interface{} {
	return &WriteArgs{}
}

func newWriteResult() interface{} {
	return &WriteResult{}
}

type WriteArgs struct {
	Req *import_sstpb.WriteRequest
}

func (p *WriteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in WriteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *WriteArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.WriteRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var WriteArgs_Req_DEFAULT *import_sstpb.WriteRequest

func (p *WriteArgs) GetReq() *import_sstpb.WriteRequest {
	if !p.IsSetReq() {
		return WriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *WriteArgs) IsSetReq() bool {
	return p.Req != nil
}

type WriteResult struct {
	Success *import_sstpb.WriteResponse
}

var WriteResult_Success_DEFAULT *import_sstpb.WriteResponse

func (p *WriteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in WriteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *WriteResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.WriteResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *WriteResult) GetSuccess() *import_sstpb.WriteResponse {
	if !p.IsSetSuccess() {
		return WriteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *WriteResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.WriteResponse)
}

func (p *WriteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rawWriteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &importSSTRawWriteServer{st}
	return handler.(import_sstpb.ImportSST).RawWrite(stream)
}

type importSSTRawWriteClient struct {
	streaming.Stream
}

func (x *importSSTRawWriteClient) Send(m *import_sstpb.RawWriteRequest) error {
	return x.Stream.SendMsg(m)
}
func (x *importSSTRawWriteClient) CloseAndRecv() (*import_sstpb.RawWriteResponse, error) {
	if err := x.Stream.Close(); err != nil {
		return nil, err
	}
	m := new(import_sstpb.RawWriteResponse)
	return m, x.Stream.RecvMsg(m)
}

type importSSTRawWriteServer struct {
	streaming.Stream
}

func (x *importSSTRawWriteServer) SendAndClose(m *import_sstpb.RawWriteResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *importSSTRawWriteServer) Recv() (*import_sstpb.RawWriteRequest, error) {
	m := new(import_sstpb.RawWriteRequest)
	return m, x.Stream.RecvMsg(m)
}

func newRawWriteArgs() interface{} {
	return &RawWriteArgs{}
}

func newRawWriteResult() interface{} {
	return &RawWriteResult{}
}

type RawWriteArgs struct {
	Req *import_sstpb.RawWriteRequest
}

func (p *RawWriteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RawWriteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RawWriteArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.RawWriteRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RawWriteArgs_Req_DEFAULT *import_sstpb.RawWriteRequest

func (p *RawWriteArgs) GetReq() *import_sstpb.RawWriteRequest {
	if !p.IsSetReq() {
		return RawWriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RawWriteArgs) IsSetReq() bool {
	return p.Req != nil
}

type RawWriteResult struct {
	Success *import_sstpb.RawWriteResponse
}

var RawWriteResult_Success_DEFAULT *import_sstpb.RawWriteResponse

func (p *RawWriteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RawWriteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RawWriteResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.RawWriteResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RawWriteResult) GetSuccess() *import_sstpb.RawWriteResponse {
	if !p.IsSetSuccess() {
		return RawWriteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RawWriteResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.RawWriteResponse)
}

func (p *RawWriteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func multiIngestHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_sstpb.MultiIngestRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_sstpb.ImportSST).MultiIngest(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MultiIngestArgs:
		success, err := handler.(import_sstpb.ImportSST).MultiIngest(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MultiIngestResult)
		realResult.Success = success
	}
	return nil
}
func newMultiIngestArgs() interface{} {
	return &MultiIngestArgs{}
}

func newMultiIngestResult() interface{} {
	return &MultiIngestResult{}
}

type MultiIngestArgs struct {
	Req *import_sstpb.MultiIngestRequest
}

func (p *MultiIngestArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in MultiIngestArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *MultiIngestArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.MultiIngestRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MultiIngestArgs_Req_DEFAULT *import_sstpb.MultiIngestRequest

func (p *MultiIngestArgs) GetReq() *import_sstpb.MultiIngestRequest {
	if !p.IsSetReq() {
		return MultiIngestArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MultiIngestArgs) IsSetReq() bool {
	return p.Req != nil
}

type MultiIngestResult struct {
	Success *import_sstpb.IngestResponse
}

var MultiIngestResult_Success_DEFAULT *import_sstpb.IngestResponse

func (p *MultiIngestResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in MultiIngestResult")
	}
	return proto.Marshal(p.Success)
}

func (p *MultiIngestResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.IngestResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MultiIngestResult) GetSuccess() *import_sstpb.IngestResponse {
	if !p.IsSetSuccess() {
		return MultiIngestResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MultiIngestResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.IngestResponse)
}

func (p *MultiIngestResult) IsSetSuccess() bool {
	return p.Success != nil
}

func duplicateDetectHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &importSSTDuplicateDetectServer{st}
	req := new(import_sstpb.DuplicateDetectRequest)
	if err := st.RecvMsg(req); err != nil {
		return err
	}
	return handler.(import_sstpb.ImportSST).DuplicateDetect(req, stream)
}

type importSSTDuplicateDetectClient struct {
	streaming.Stream
}

func (x *importSSTDuplicateDetectClient) Recv() (*import_sstpb.DuplicateDetectResponse, error) {
	m := new(import_sstpb.DuplicateDetectResponse)
	return m, x.Stream.RecvMsg(m)
}

type importSSTDuplicateDetectServer struct {
	streaming.Stream
}

func (x *importSSTDuplicateDetectServer) Send(m *import_sstpb.DuplicateDetectResponse) error {
	return x.Stream.SendMsg(m)
}

func newDuplicateDetectArgs() interface{} {
	return &DuplicateDetectArgs{}
}

func newDuplicateDetectResult() interface{} {
	return &DuplicateDetectResult{}
}

type DuplicateDetectArgs struct {
	Req *import_sstpb.DuplicateDetectRequest
}

func (p *DuplicateDetectArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DuplicateDetectArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DuplicateDetectArgs) Unmarshal(in []byte) error {
	msg := new(import_sstpb.DuplicateDetectRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DuplicateDetectArgs_Req_DEFAULT *import_sstpb.DuplicateDetectRequest

func (p *DuplicateDetectArgs) GetReq() *import_sstpb.DuplicateDetectRequest {
	if !p.IsSetReq() {
		return DuplicateDetectArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DuplicateDetectArgs) IsSetReq() bool {
	return p.Req != nil
}

type DuplicateDetectResult struct {
	Success *import_sstpb.DuplicateDetectResponse
}

var DuplicateDetectResult_Success_DEFAULT *import_sstpb.DuplicateDetectResponse

func (p *DuplicateDetectResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DuplicateDetectResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DuplicateDetectResult) Unmarshal(in []byte) error {
	msg := new(import_sstpb.DuplicateDetectResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DuplicateDetectResult) GetSuccess() *import_sstpb.DuplicateDetectResponse {
	if !p.IsSetSuccess() {
		return DuplicateDetectResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DuplicateDetectResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_sstpb.DuplicateDetectResponse)
}

func (p *DuplicateDetectResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) SwitchMode(ctx context.Context, Req *import_sstpb.SwitchModeRequest) (r *import_sstpb.SwitchModeResponse, err error) {
	var _args SwitchModeArgs
	_args.Req = Req
	var _result SwitchModeResult
	if err = p.c.Call(ctx, "SwitchMode", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Upload(ctx context.Context) (ImportSST_UploadClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "Upload", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &importSSTUploadClient{res.Stream}
	return stream, nil
}

func (p *kClient) Ingest(ctx context.Context, Req *import_sstpb.IngestRequest) (r *import_sstpb.IngestResponse, err error) {
	var _args IngestArgs
	_args.Req = Req
	var _result IngestResult
	if err = p.c.Call(ctx, "Ingest", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Compact(ctx context.Context, Req *import_sstpb.CompactRequest) (r *import_sstpb.CompactResponse, err error) {
	var _args CompactArgs
	_args.Req = Req
	var _result CompactResult
	if err = p.c.Call(ctx, "Compact", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) SetDownloadSpeedLimit(ctx context.Context, Req *import_sstpb.SetDownloadSpeedLimitRequest) (r *import_sstpb.SetDownloadSpeedLimitResponse, err error) {
	var _args SetDownloadSpeedLimitArgs
	_args.Req = Req
	var _result SetDownloadSpeedLimitResult
	if err = p.c.Call(ctx, "SetDownloadSpeedLimit", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Download(ctx context.Context, Req *import_sstpb.DownloadRequest) (r *import_sstpb.DownloadResponse, err error) {
	var _args DownloadArgs
	_args.Req = Req
	var _result DownloadResult
	if err = p.c.Call(ctx, "Download", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Write(ctx context.Context) (ImportSST_WriteClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "Write", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &importSSTWriteClient{res.Stream}
	return stream, nil
}

func (p *kClient) RawWrite(ctx context.Context) (ImportSST_RawWriteClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "RawWrite", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &importSSTRawWriteClient{res.Stream}
	return stream, nil
}

func (p *kClient) MultiIngest(ctx context.Context, Req *import_sstpb.MultiIngestRequest) (r *import_sstpb.IngestResponse, err error) {
	var _args MultiIngestArgs
	_args.Req = Req
	var _result MultiIngestResult
	if err = p.c.Call(ctx, "MultiIngest", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DuplicateDetect(ctx context.Context, req *import_sstpb.DuplicateDetectRequest) (ImportSST_DuplicateDetectClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "DuplicateDetect", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &importSSTDuplicateDetectClient{res.Stream}
	if err := stream.Stream.SendMsg(req); err != nil {
		return nil, err
	}
	if err := stream.Stream.Close(); err != nil {
		return nil, err
	}
	return stream, nil
}
