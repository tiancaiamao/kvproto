// Code generated by Kitex v0.1.3. DO NOT EDIT.

package importkv

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/pingcap/kvproto/proto/kitex_gen/import_kvpb"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return importKVServiceInfo
}

var importKVServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "ImportKV"
	handlerType := (*import_kvpb.ImportKV)(nil)
	methods := map[string]kitex.MethodInfo{
		"SwitchMode":     kitex.NewMethodInfo(switchModeHandler, newSwitchModeArgs, newSwitchModeResult, false),
		"OpenEngine":     kitex.NewMethodInfo(openEngineHandler, newOpenEngineArgs, newOpenEngineResult, false),
		"WriteEngine":    kitex.NewMethodInfo(writeEngineHandler, newWriteEngineArgs, newWriteEngineResult, false),
		"WriteEngineV3":  kitex.NewMethodInfo(writeEngineV3Handler, newWriteEngineV3Args, newWriteEngineV3Result, false),
		"CloseEngine":    kitex.NewMethodInfo(closeEngineHandler, newCloseEngineArgs, newCloseEngineResult, false),
		"ImportEngine":   kitex.NewMethodInfo(importEngineHandler, newImportEngineArgs, newImportEngineResult, false),
		"CleanupEngine":  kitex.NewMethodInfo(cleanupEngineHandler, newCleanupEngineArgs, newCleanupEngineResult, false),
		"CompactCluster": kitex.NewMethodInfo(compactClusterHandler, newCompactClusterArgs, newCompactClusterResult, false),
		"GetVersion":     kitex.NewMethodInfo(getVersionHandler, newGetVersionArgs, newGetVersionResult, false),
		"GetMetrics":     kitex.NewMethodInfo(getMetricsHandler, newGetMetricsArgs, newGetMetricsResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "import_kvpb",
	}
	extra["streaming"] = true
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.1.3",
		Extra:           extra,
	}
	return svcInfo
}

func switchModeHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_kvpb.SwitchModeRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_kvpb.ImportKV).SwitchMode(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *SwitchModeArgs:
		success, err := handler.(import_kvpb.ImportKV).SwitchMode(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*SwitchModeResult)
		realResult.Success = success
	}
	return nil
}
func newSwitchModeArgs() interface{} {
	return &SwitchModeArgs{}
}

func newSwitchModeResult() interface{} {
	return &SwitchModeResult{}
}

type SwitchModeArgs struct {
	Req *import_kvpb.SwitchModeRequest
}

func (p *SwitchModeArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in SwitchModeArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *SwitchModeArgs) Unmarshal(in []byte) error {
	msg := new(import_kvpb.SwitchModeRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var SwitchModeArgs_Req_DEFAULT *import_kvpb.SwitchModeRequest

func (p *SwitchModeArgs) GetReq() *import_kvpb.SwitchModeRequest {
	if !p.IsSetReq() {
		return SwitchModeArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *SwitchModeArgs) IsSetReq() bool {
	return p.Req != nil
}

type SwitchModeResult struct {
	Success *import_kvpb.SwitchModeResponse
}

var SwitchModeResult_Success_DEFAULT *import_kvpb.SwitchModeResponse

func (p *SwitchModeResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in SwitchModeResult")
	}
	return proto.Marshal(p.Success)
}

func (p *SwitchModeResult) Unmarshal(in []byte) error {
	msg := new(import_kvpb.SwitchModeResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *SwitchModeResult) GetSuccess() *import_kvpb.SwitchModeResponse {
	if !p.IsSetSuccess() {
		return SwitchModeResult_Success_DEFAULT
	}
	return p.Success
}

func (p *SwitchModeResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.SwitchModeResponse)
}

func (p *SwitchModeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func openEngineHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_kvpb.OpenEngineRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_kvpb.ImportKV).OpenEngine(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *OpenEngineArgs:
		success, err := handler.(import_kvpb.ImportKV).OpenEngine(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*OpenEngineResult)
		realResult.Success = success
	}
	return nil
}
func newOpenEngineArgs() interface{} {
	return &OpenEngineArgs{}
}

func newOpenEngineResult() interface{} {
	return &OpenEngineResult{}
}

type OpenEngineArgs struct {
	Req *import_kvpb.OpenEngineRequest
}

func (p *OpenEngineArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in OpenEngineArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *OpenEngineArgs) Unmarshal(in []byte) error {
	msg := new(import_kvpb.OpenEngineRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var OpenEngineArgs_Req_DEFAULT *import_kvpb.OpenEngineRequest

func (p *OpenEngineArgs) GetReq() *import_kvpb.OpenEngineRequest {
	if !p.IsSetReq() {
		return OpenEngineArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *OpenEngineArgs) IsSetReq() bool {
	return p.Req != nil
}

type OpenEngineResult struct {
	Success *import_kvpb.OpenEngineResponse
}

var OpenEngineResult_Success_DEFAULT *import_kvpb.OpenEngineResponse

func (p *OpenEngineResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in OpenEngineResult")
	}
	return proto.Marshal(p.Success)
}

func (p *OpenEngineResult) Unmarshal(in []byte) error {
	msg := new(import_kvpb.OpenEngineResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *OpenEngineResult) GetSuccess() *import_kvpb.OpenEngineResponse {
	if !p.IsSetSuccess() {
		return OpenEngineResult_Success_DEFAULT
	}
	return p.Success
}

func (p *OpenEngineResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.OpenEngineResponse)
}

func (p *OpenEngineResult) IsSetSuccess() bool {
	return p.Success != nil
}

func writeEngineHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	st := arg.(*streaming.Args).Stream
	stream := &importKVWriteEngineServer{st}
	return handler.(import_kvpb.ImportKV).WriteEngine(stream)
}

type importKVWriteEngineClient struct {
	streaming.Stream
}

func (x *importKVWriteEngineClient) Send(m *import_kvpb.WriteEngineRequest) error {
	return x.Stream.SendMsg(m)
}
func (x *importKVWriteEngineClient) CloseAndRecv() (*import_kvpb.WriteEngineResponse, error) {
	if err := x.Stream.Close(); err != nil {
		return nil, err
	}
	m := new(import_kvpb.WriteEngineResponse)
	return m, x.Stream.RecvMsg(m)
}

type importKVWriteEngineServer struct {
	streaming.Stream
}

func (x *importKVWriteEngineServer) SendAndClose(m *import_kvpb.WriteEngineResponse) error {
	return x.Stream.SendMsg(m)
}

func (x *importKVWriteEngineServer) Recv() (*import_kvpb.WriteEngineRequest, error) {
	m := new(import_kvpb.WriteEngineRequest)
	return m, x.Stream.RecvMsg(m)
}

func newWriteEngineArgs() interface{} {
	return &WriteEngineArgs{}
}

func newWriteEngineResult() interface{} {
	return &WriteEngineResult{}
}

type WriteEngineArgs struct {
	Req *import_kvpb.WriteEngineRequest
}

func (p *WriteEngineArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in WriteEngineArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *WriteEngineArgs) Unmarshal(in []byte) error {
	msg := new(import_kvpb.WriteEngineRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var WriteEngineArgs_Req_DEFAULT *import_kvpb.WriteEngineRequest

func (p *WriteEngineArgs) GetReq() *import_kvpb.WriteEngineRequest {
	if !p.IsSetReq() {
		return WriteEngineArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *WriteEngineArgs) IsSetReq() bool {
	return p.Req != nil
}

type WriteEngineResult struct {
	Success *import_kvpb.WriteEngineResponse
}

var WriteEngineResult_Success_DEFAULT *import_kvpb.WriteEngineResponse

func (p *WriteEngineResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in WriteEngineResult")
	}
	return proto.Marshal(p.Success)
}

func (p *WriteEngineResult) Unmarshal(in []byte) error {
	msg := new(import_kvpb.WriteEngineResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *WriteEngineResult) GetSuccess() *import_kvpb.WriteEngineResponse {
	if !p.IsSetSuccess() {
		return WriteEngineResult_Success_DEFAULT
	}
	return p.Success
}

func (p *WriteEngineResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.WriteEngineResponse)
}

func (p *WriteEngineResult) IsSetSuccess() bool {
	return p.Success != nil
}

func writeEngineV3Handler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_kvpb.WriteEngineV3Request)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_kvpb.ImportKV).WriteEngineV3(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *WriteEngineV3Args:
		success, err := handler.(import_kvpb.ImportKV).WriteEngineV3(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*WriteEngineV3Result)
		realResult.Success = success
	}
	return nil
}
func newWriteEngineV3Args() interface{} {
	return &WriteEngineV3Args{}
}

func newWriteEngineV3Result() interface{} {
	return &WriteEngineV3Result{}
}

type WriteEngineV3Args struct {
	Req *import_kvpb.WriteEngineV3Request
}

func (p *WriteEngineV3Args) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in WriteEngineV3Args")
	}
	return proto.Marshal(p.Req)
}

func (p *WriteEngineV3Args) Unmarshal(in []byte) error {
	msg := new(import_kvpb.WriteEngineV3Request)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var WriteEngineV3Args_Req_DEFAULT *import_kvpb.WriteEngineV3Request

func (p *WriteEngineV3Args) GetReq() *import_kvpb.WriteEngineV3Request {
	if !p.IsSetReq() {
		return WriteEngineV3Args_Req_DEFAULT
	}
	return p.Req
}

func (p *WriteEngineV3Args) IsSetReq() bool {
	return p.Req != nil
}

type WriteEngineV3Result struct {
	Success *import_kvpb.WriteEngineResponse
}

var WriteEngineV3Result_Success_DEFAULT *import_kvpb.WriteEngineResponse

func (p *WriteEngineV3Result) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in WriteEngineV3Result")
	}
	return proto.Marshal(p.Success)
}

func (p *WriteEngineV3Result) Unmarshal(in []byte) error {
	msg := new(import_kvpb.WriteEngineResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *WriteEngineV3Result) GetSuccess() *import_kvpb.WriteEngineResponse {
	if !p.IsSetSuccess() {
		return WriteEngineV3Result_Success_DEFAULT
	}
	return p.Success
}

func (p *WriteEngineV3Result) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.WriteEngineResponse)
}

func (p *WriteEngineV3Result) IsSetSuccess() bool {
	return p.Success != nil
}

func closeEngineHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_kvpb.CloseEngineRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_kvpb.ImportKV).CloseEngine(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CloseEngineArgs:
		success, err := handler.(import_kvpb.ImportKV).CloseEngine(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CloseEngineResult)
		realResult.Success = success
	}
	return nil
}
func newCloseEngineArgs() interface{} {
	return &CloseEngineArgs{}
}

func newCloseEngineResult() interface{} {
	return &CloseEngineResult{}
}

type CloseEngineArgs struct {
	Req *import_kvpb.CloseEngineRequest
}

func (p *CloseEngineArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CloseEngineArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CloseEngineArgs) Unmarshal(in []byte) error {
	msg := new(import_kvpb.CloseEngineRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CloseEngineArgs_Req_DEFAULT *import_kvpb.CloseEngineRequest

func (p *CloseEngineArgs) GetReq() *import_kvpb.CloseEngineRequest {
	if !p.IsSetReq() {
		return CloseEngineArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CloseEngineArgs) IsSetReq() bool {
	return p.Req != nil
}

type CloseEngineResult struct {
	Success *import_kvpb.CloseEngineResponse
}

var CloseEngineResult_Success_DEFAULT *import_kvpb.CloseEngineResponse

func (p *CloseEngineResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CloseEngineResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CloseEngineResult) Unmarshal(in []byte) error {
	msg := new(import_kvpb.CloseEngineResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CloseEngineResult) GetSuccess() *import_kvpb.CloseEngineResponse {
	if !p.IsSetSuccess() {
		return CloseEngineResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CloseEngineResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.CloseEngineResponse)
}

func (p *CloseEngineResult) IsSetSuccess() bool {
	return p.Success != nil
}

func importEngineHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_kvpb.ImportEngineRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_kvpb.ImportKV).ImportEngine(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *ImportEngineArgs:
		success, err := handler.(import_kvpb.ImportKV).ImportEngine(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*ImportEngineResult)
		realResult.Success = success
	}
	return nil
}
func newImportEngineArgs() interface{} {
	return &ImportEngineArgs{}
}

func newImportEngineResult() interface{} {
	return &ImportEngineResult{}
}

type ImportEngineArgs struct {
	Req *import_kvpb.ImportEngineRequest
}

func (p *ImportEngineArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in ImportEngineArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *ImportEngineArgs) Unmarshal(in []byte) error {
	msg := new(import_kvpb.ImportEngineRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var ImportEngineArgs_Req_DEFAULT *import_kvpb.ImportEngineRequest

func (p *ImportEngineArgs) GetReq() *import_kvpb.ImportEngineRequest {
	if !p.IsSetReq() {
		return ImportEngineArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ImportEngineArgs) IsSetReq() bool {
	return p.Req != nil
}

type ImportEngineResult struct {
	Success *import_kvpb.ImportEngineResponse
}

var ImportEngineResult_Success_DEFAULT *import_kvpb.ImportEngineResponse

func (p *ImportEngineResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in ImportEngineResult")
	}
	return proto.Marshal(p.Success)
}

func (p *ImportEngineResult) Unmarshal(in []byte) error {
	msg := new(import_kvpb.ImportEngineResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *ImportEngineResult) GetSuccess() *import_kvpb.ImportEngineResponse {
	if !p.IsSetSuccess() {
		return ImportEngineResult_Success_DEFAULT
	}
	return p.Success
}

func (p *ImportEngineResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.ImportEngineResponse)
}

func (p *ImportEngineResult) IsSetSuccess() bool {
	return p.Success != nil
}

func cleanupEngineHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_kvpb.CleanupEngineRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_kvpb.ImportKV).CleanupEngine(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CleanupEngineArgs:
		success, err := handler.(import_kvpb.ImportKV).CleanupEngine(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CleanupEngineResult)
		realResult.Success = success
	}
	return nil
}
func newCleanupEngineArgs() interface{} {
	return &CleanupEngineArgs{}
}

func newCleanupEngineResult() interface{} {
	return &CleanupEngineResult{}
}

type CleanupEngineArgs struct {
	Req *import_kvpb.CleanupEngineRequest
}

func (p *CleanupEngineArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CleanupEngineArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CleanupEngineArgs) Unmarshal(in []byte) error {
	msg := new(import_kvpb.CleanupEngineRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CleanupEngineArgs_Req_DEFAULT *import_kvpb.CleanupEngineRequest

func (p *CleanupEngineArgs) GetReq() *import_kvpb.CleanupEngineRequest {
	if !p.IsSetReq() {
		return CleanupEngineArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CleanupEngineArgs) IsSetReq() bool {
	return p.Req != nil
}

type CleanupEngineResult struct {
	Success *import_kvpb.CleanupEngineResponse
}

var CleanupEngineResult_Success_DEFAULT *import_kvpb.CleanupEngineResponse

func (p *CleanupEngineResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CleanupEngineResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CleanupEngineResult) Unmarshal(in []byte) error {
	msg := new(import_kvpb.CleanupEngineResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CleanupEngineResult) GetSuccess() *import_kvpb.CleanupEngineResponse {
	if !p.IsSetSuccess() {
		return CleanupEngineResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CleanupEngineResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.CleanupEngineResponse)
}

func (p *CleanupEngineResult) IsSetSuccess() bool {
	return p.Success != nil
}

func compactClusterHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_kvpb.CompactClusterRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_kvpb.ImportKV).CompactCluster(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CompactClusterArgs:
		success, err := handler.(import_kvpb.ImportKV).CompactCluster(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CompactClusterResult)
		realResult.Success = success
	}
	return nil
}
func newCompactClusterArgs() interface{} {
	return &CompactClusterArgs{}
}

func newCompactClusterResult() interface{} {
	return &CompactClusterResult{}
}

type CompactClusterArgs struct {
	Req *import_kvpb.CompactClusterRequest
}

func (p *CompactClusterArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CompactClusterArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CompactClusterArgs) Unmarshal(in []byte) error {
	msg := new(import_kvpb.CompactClusterRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CompactClusterArgs_Req_DEFAULT *import_kvpb.CompactClusterRequest

func (p *CompactClusterArgs) GetReq() *import_kvpb.CompactClusterRequest {
	if !p.IsSetReq() {
		return CompactClusterArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CompactClusterArgs) IsSetReq() bool {
	return p.Req != nil
}

type CompactClusterResult struct {
	Success *import_kvpb.CompactClusterResponse
}

var CompactClusterResult_Success_DEFAULT *import_kvpb.CompactClusterResponse

func (p *CompactClusterResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CompactClusterResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CompactClusterResult) Unmarshal(in []byte) error {
	msg := new(import_kvpb.CompactClusterResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CompactClusterResult) GetSuccess() *import_kvpb.CompactClusterResponse {
	if !p.IsSetSuccess() {
		return CompactClusterResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CompactClusterResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.CompactClusterResponse)
}

func (p *CompactClusterResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getVersionHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_kvpb.GetVersionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_kvpb.ImportKV).GetVersion(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetVersionArgs:
		success, err := handler.(import_kvpb.ImportKV).GetVersion(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVersionResult)
		realResult.Success = success
	}
	return nil
}
func newGetVersionArgs() interface{} {
	return &GetVersionArgs{}
}

func newGetVersionResult() interface{} {
	return &GetVersionResult{}
}

type GetVersionArgs struct {
	Req *import_kvpb.GetVersionRequest
}

func (p *GetVersionArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetVersionArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetVersionArgs) Unmarshal(in []byte) error {
	msg := new(import_kvpb.GetVersionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVersionArgs_Req_DEFAULT *import_kvpb.GetVersionRequest

func (p *GetVersionArgs) GetReq() *import_kvpb.GetVersionRequest {
	if !p.IsSetReq() {
		return GetVersionArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVersionArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetVersionResult struct {
	Success *import_kvpb.GetVersionResponse
}

var GetVersionResult_Success_DEFAULT *import_kvpb.GetVersionResponse

func (p *GetVersionResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetVersionResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetVersionResult) Unmarshal(in []byte) error {
	msg := new(import_kvpb.GetVersionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVersionResult) GetSuccess() *import_kvpb.GetVersionResponse {
	if !p.IsSetSuccess() {
		return GetVersionResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVersionResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.GetVersionResponse)
}

func (p *GetVersionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getMetricsHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(import_kvpb.GetMetricsRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(import_kvpb.ImportKV).GetMetrics(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetMetricsArgs:
		success, err := handler.(import_kvpb.ImportKV).GetMetrics(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetMetricsResult)
		realResult.Success = success
	}
	return nil
}
func newGetMetricsArgs() interface{} {
	return &GetMetricsArgs{}
}

func newGetMetricsResult() interface{} {
	return &GetMetricsResult{}
}

type GetMetricsArgs struct {
	Req *import_kvpb.GetMetricsRequest
}

func (p *GetMetricsArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetMetricsArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetMetricsArgs) Unmarshal(in []byte) error {
	msg := new(import_kvpb.GetMetricsRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetMetricsArgs_Req_DEFAULT *import_kvpb.GetMetricsRequest

func (p *GetMetricsArgs) GetReq() *import_kvpb.GetMetricsRequest {
	if !p.IsSetReq() {
		return GetMetricsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetMetricsArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetMetricsResult struct {
	Success *import_kvpb.GetMetricsResponse
}

var GetMetricsResult_Success_DEFAULT *import_kvpb.GetMetricsResponse

func (p *GetMetricsResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetMetricsResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetMetricsResult) Unmarshal(in []byte) error {
	msg := new(import_kvpb.GetMetricsResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetMetricsResult) GetSuccess() *import_kvpb.GetMetricsResponse {
	if !p.IsSetSuccess() {
		return GetMetricsResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetMetricsResult) SetSuccess(x interface{}) {
	p.Success = x.(*import_kvpb.GetMetricsResponse)
}

func (p *GetMetricsResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) SwitchMode(ctx context.Context, Req *import_kvpb.SwitchModeRequest) (r *import_kvpb.SwitchModeResponse, err error) {
	var _args SwitchModeArgs
	_args.Req = Req
	var _result SwitchModeResult
	if err = p.c.Call(ctx, "SwitchMode", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) OpenEngine(ctx context.Context, Req *import_kvpb.OpenEngineRequest) (r *import_kvpb.OpenEngineResponse, err error) {
	var _args OpenEngineArgs
	_args.Req = Req
	var _result OpenEngineResult
	if err = p.c.Call(ctx, "OpenEngine", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) WriteEngine(ctx context.Context) (ImportKV_WriteEngineClient, error) {
	streamClient, ok := p.c.(client.Streaming)
	if !ok {
		return nil, fmt.Errorf("client not support streaming")
	}
	res := new(streaming.Result)
	err := streamClient.Stream(ctx, "WriteEngine", nil, res)
	if err != nil {
		return nil, err
	}
	stream := &importKVWriteEngineClient{res.Stream}
	return stream, nil
}

func (p *kClient) WriteEngineV3(ctx context.Context, Req *import_kvpb.WriteEngineV3Request) (r *import_kvpb.WriteEngineResponse, err error) {
	var _args WriteEngineV3Args
	_args.Req = Req
	var _result WriteEngineV3Result
	if err = p.c.Call(ctx, "WriteEngineV3", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CloseEngine(ctx context.Context, Req *import_kvpb.CloseEngineRequest) (r *import_kvpb.CloseEngineResponse, err error) {
	var _args CloseEngineArgs
	_args.Req = Req
	var _result CloseEngineResult
	if err = p.c.Call(ctx, "CloseEngine", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) ImportEngine(ctx context.Context, Req *import_kvpb.ImportEngineRequest) (r *import_kvpb.ImportEngineResponse, err error) {
	var _args ImportEngineArgs
	_args.Req = Req
	var _result ImportEngineResult
	if err = p.c.Call(ctx, "ImportEngine", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CleanupEngine(ctx context.Context, Req *import_kvpb.CleanupEngineRequest) (r *import_kvpb.CleanupEngineResponse, err error) {
	var _args CleanupEngineArgs
	_args.Req = Req
	var _result CleanupEngineResult
	if err = p.c.Call(ctx, "CleanupEngine", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CompactCluster(ctx context.Context, Req *import_kvpb.CompactClusterRequest) (r *import_kvpb.CompactClusterResponse, err error) {
	var _args CompactClusterArgs
	_args.Req = Req
	var _result CompactClusterResult
	if err = p.c.Call(ctx, "CompactCluster", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVersion(ctx context.Context, Req *import_kvpb.GetVersionRequest) (r *import_kvpb.GetVersionResponse, err error) {
	var _args GetVersionArgs
	_args.Req = Req
	var _result GetVersionResult
	if err = p.c.Call(ctx, "GetVersion", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetMetrics(ctx context.Context, Req *import_kvpb.GetMetricsRequest) (r *import_kvpb.GetMetricsResponse, err error) {
	var _args GetMetricsArgs
	_args.Req = Req
	var _result GetMetricsResult
	if err = p.c.Call(ctx, "GetMetrics", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
